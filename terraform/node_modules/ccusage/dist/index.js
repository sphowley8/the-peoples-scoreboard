#!/usr/bin/env node
import { $ as DEFAULT_RECENT_DAYS, B as pushBreakdownRows, D as calculateBurnRate, E as DEFAULT_SESSION_DURATION_HOURS, F as formatDateCompact, G as BLOCKS_COMPACT_WIDTH_THRESHOLD, H as getFileModifiedTime, I as formatModelsDisplayMultiline, K as BLOCKS_DEFAULT_TERMINAL_WIDTH, L as formatNumber, M as addEmptySeparatorRow, N as createUsageReportTable, O as filterRecentBlocks, P as formatCurrency, Q as DEFAULT_LOCALE, R as formatTotalsRow, U as unreachable, V as require_picocolors, W as _usingCtx, Y as CONFIG_FILE_NAME, Z as DEFAULT_CONTEXT_USAGE_THRESHOLDS, _ as loadWeeklyUsageData, at as try_, ct as inspectError, dt as isSuccess, et as DEFAULT_REFRESH_INTERVAL_SECONDS, f as loadDailyUsageData, ft as isFailure, g as loadSessionUsageById, h as loadSessionData, it as unwrap, j as ResponsiveTable, k as projectBlockUsage, lt as inspect, m as loadSessionBlockData, mt as __toESM, n as calculateContextTokens, nt as WEEK_DAYS, ot as pipe, p as loadMonthlyUsageData, pt as toArray, q as BLOCKS_WARNING_THRESHOLD, s as getClaudePaths, st as map$1, ut as succeed, z as formatUsageDataRow } from "./data-loader-WtLWGEXB.js";
import { D as maxValue, E as integer$1, F as string, I as transform, L as trim, M as parse$1, N as pipe$1, O as minValue, P as safeParse, R as union, T as flatten, d as filterDateSchema, k as number, n as SortOrders, t as CostModes, w as check, y as statuslineHookJsonSchema, z as getTotalTokens } from "./_types-BFL_bTNX.js";
import { n as createTotalsObject, t as calculateTotals } from "./calculate-cost-CKH-OC_c.js";
import { a as version, i as name, n as logger, r as description, t as log } from "./logger-CCLoO8UB.js";
import { n as printMismatchReport, t as detectMismatches } from "./debug-DeaOC7Wv.js";
import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import a from "node:fs/promises";
import path, { join } from "node:path";
import process$1 from "node:process";
import { tmpdir } from "node:os";
import { fileURLToPath } from "node:url";
import { stripVTControlCharacters } from "node:util";
import { spawn } from "node:child_process";
import { on, once } from "node:events";
import { pipeline } from "node:stream/promises";
import * as readline from "node:readline/promises";
const DEFAULT_LOCALE$1 = "en-US";
const BUILT_IN_PREFIX = "_";
const ARG_PREFIX = "arg";
const BUILT_IN_KEY_SEPARATOR = ":";
const ANONYMOUS_COMMAND_NAME = "(anonymous)";
const NOOP = () => {};
const COMMON_ARGS = {
	help: {
		type: "boolean",
		short: "h",
		description: "Display this help message"
	},
	version: {
		type: "boolean",
		short: "v",
		description: "Display this version"
	}
};
const COMMAND_OPTIONS_DEFAULT = {
	name: void 0,
	description: void 0,
	version: void 0,
	cwd: void 0,
	usageSilent: false,
	subCommands: void 0,
	leftMargin: 2,
	middleMargin: 10,
	usageOptionType: false,
	usageOptionValue: true,
	renderHeader: void 0,
	renderUsage: void 0,
	renderValidationErrors: void 0,
	translationAdapterFactory: void 0
};
function isLazyCommand(cmd) {
	return typeof cmd === "function" && "commandName" in cmd && !!cmd.commandName;
}
async function resolveLazyCommand(cmd, name$1, needRunResolving = false) {
	let command;
	if (isLazyCommand(cmd)) {
		command = Object.assign(create(), {
			name: cmd.commandName,
			description: cmd.description,
			args: cmd.args,
			examples: cmd.examples,
			resource: cmd.resource
		});
		if (needRunResolving) {
			const loaded = await cmd();
			if (typeof loaded === "function") command.run = loaded;
			else if (typeof loaded === "object") {
				if (loaded.run == null) throw new TypeError(`'run' is required in command: ${cmd.name || name$1}`);
				command.run = loaded.run;
				command.name = loaded.name;
				command.description = loaded.description;
				command.args = loaded.args;
				command.examples = loaded.examples;
				command.resource = loaded.resource;
			} else throw new TypeError(`Cannot resolve command: ${cmd.name || name$1}`);
		}
	} else command = Object.assign(create(), cmd);
	if (command.name == null && name$1) command.name = name$1;
	return deepFreeze(command);
}
function resolveBuiltInKey(key) {
	return `${BUILT_IN_PREFIX}${BUILT_IN_KEY_SEPARATOR}${key}`;
}
function resolveArgKey(key) {
	return `${ARG_PREFIX}${BUILT_IN_KEY_SEPARATOR}${key}`;
}
async function resolveExamples(ctx, examples) {
	return typeof examples === "string" ? examples : typeof examples === "function" ? await examples(ctx) : "";
}
function mapResourceWithBuiltinKey(resource) {
	return Object.entries(resource).reduce((acc, [key, value$1]) => {
		acc[resolveBuiltInKey(key)] = value$1;
		return acc;
	}, create());
}
function create(obj = null) {
	return Object.create(obj);
}
function log$1(...args) {
	console.log(...args);
}
function deepFreeze(obj) {
	if (obj === null || typeof obj !== "object") return obj;
	for (const key of Object.keys(obj)) {
		const value$1 = obj[key];
		if (typeof value$1 === "object" && value$1 !== null) deepFreeze(value$1);
	}
	return Object.freeze(obj);
}
var en_US_default = {
	COMMAND: "COMMAND",
	COMMANDS: "COMMANDS",
	SUBCOMMAND: "SUBCOMMAND",
	USAGE: "USAGE",
	ARGUMENTS: "ARGUMENTS",
	OPTIONS: "OPTIONS",
	EXAMPLES: "EXAMPLES",
	FORMORE: "For more info, run any command with the `--help` flag:",
	NEGATABLE: "Negatable of",
	DEFAULT: "default",
	CHOICES: "choices",
	help: "Display this help message",
	version: "Display this version"
};
function createTranslationAdapter(options) {
	return new DefaultTranslation(options);
}
var DefaultTranslation = class {
	#resources = /* @__PURE__ */ new Map();
	#options;
	constructor(options) {
		this.#options = options;
		this.#resources.set(options.locale, create());
		if (options.locale !== options.fallbackLocale) this.#resources.set(options.fallbackLocale, create());
	}
	getResource(locale) {
		return this.#resources.get(locale);
	}
	setResource(locale, resource) {
		this.#resources.set(locale, resource);
	}
	getMessage(locale, key) {
		const resource = this.getResource(locale);
		if (resource) return resource[key];
	}
	translate(locale, key, values = create()) {
		let message = this.getMessage(locale, key);
		if (message === void 0 && locale !== this.#options.fallbackLocale) message = this.getMessage(this.#options.fallbackLocale, key);
		if (message === void 0) return;
		return message.replaceAll(/\{\{(\w+)\}\}/g, (_$1, name$1) => {
			return values[name$1] == null ? "" : values[name$1].toString();
		});
	}
};
const BUILT_IN_PREFIX_CODE = BUILT_IN_PREFIX.codePointAt(0);
async function createCommandContext({ args, values, positionals, rest, argv, tokens, command, cliOptions, callMode = "entry", omitted = false }) {
	const _args = Object.entries(args).reduce((acc, [key, value$1]) => {
		acc[key] = Object.assign(create(), value$1);
		return acc;
	}, create());
	const env = Object.assign(create(), COMMAND_OPTIONS_DEFAULT, cliOptions);
	const locale = resolveLocale(cliOptions.locale);
	const localeStr = locale.toString();
	const adapter = (cliOptions.translationAdapterFactory || createTranslationAdapter)({
		locale: localeStr,
		fallbackLocale: DEFAULT_LOCALE$1
	});
	const localeResources = /* @__PURE__ */ new Map();
	let builtInLoadedResources;
	localeResources.set(DEFAULT_LOCALE$1, mapResourceWithBuiltinKey(en_US_default));
	if (DEFAULT_LOCALE$1 !== localeStr) try {
		builtInLoadedResources = (await import(`./locales/${localeStr}.json`, { with: { type: "json" } })).default;
		localeResources.set(localeStr, mapResourceWithBuiltinKey(builtInLoadedResources));
	} catch {}
	function translate(key, values$1 = create()) {
		const strKey = key;
		if (strKey.codePointAt(0) === BUILT_IN_PREFIX_CODE) return (localeResources.get(localeStr) || localeResources.get(DEFAULT_LOCALE$1))[strKey] || strKey;
		else return adapter.translate(locale.toString(), strKey, values$1) || "";
	}
	let cachedCommands;
	async function loadCommands() {
		if (cachedCommands) return cachedCommands;
		const subCommands$1 = [...cliOptions.subCommands || []];
		return cachedCommands = await Promise.all(subCommands$1.map(async ([name$1, cmd]) => await resolveLazyCommand(cmd, name$1)));
	}
	const ctx = deepFreeze(Object.assign(create(), {
		name: getCommandName(command),
		description: command.description,
		omitted,
		callMode,
		locale,
		env,
		args: _args,
		values,
		positionals,
		rest,
		_: argv,
		tokens,
		toKebab: command.toKebab,
		log: cliOptions.usageSilent ? NOOP : log$1,
		loadCommands,
		translate
	}));
	const defaultCommandResource = Object.entries(args).map(([key, arg]) => {
		return [key, arg.description || ""];
	}).reduce((res, [key, value$1]) => {
		res[resolveArgKey(key)] = value$1;
		return res;
	}, create());
	defaultCommandResource.description = command.description || "";
	defaultCommandResource.examples = await resolveExamples(ctx, command.examples);
	adapter.setResource(DEFAULT_LOCALE$1, defaultCommandResource);
	const originalResource = await loadCommandResource(ctx, command);
	if (originalResource) {
		const resource = Object.assign(create(), originalResource, { examples: await resolveExamples(ctx, originalResource.examples) });
		if (builtInLoadedResources) {
			resource.help = builtInLoadedResources.help;
			resource.version = builtInLoadedResources.version;
		}
		adapter.setResource(localeStr, resource);
	}
	return ctx;
}
function getCommandName(cmd) {
	if (isLazyCommand(cmd)) return cmd.commandName || cmd.name || ANONYMOUS_COMMAND_NAME;
	else if (typeof cmd === "object") return cmd.name || ANONYMOUS_COMMAND_NAME;
	else return ANONYMOUS_COMMAND_NAME;
}
function resolveLocale(locale) {
	return locale instanceof Intl.Locale ? locale : typeof locale === "string" ? new Intl.Locale(locale) : new Intl.Locale(DEFAULT_LOCALE$1);
}
async function loadCommandResource(ctx, command) {
	let resource;
	try {
		resource = await command.resource?.(ctx);
	} catch {}
	return resource;
}
function define(definition) {
	return definition;
}
/**
* @author kazuya kawaguchi (a.k.a. kazupon)
* @license MIT
*/
function kebabnize(str$1) {
	return str$1.replace(/[A-Z]/g, (match, offset) => (offset > 0 ? "-" : "") + match.toLowerCase());
}
function renderHeader(ctx) {
	const title = ctx.env.description || ctx.env.name || "";
	return Promise.resolve(title ? `${title} (${ctx.env.name || ""}${ctx.env.version ? ` v${ctx.env.version}` : ""})` : title);
}
const COMMON_ARGS_KEYS = Object.keys(COMMON_ARGS);
async function renderUsage(ctx) {
	const messages = [];
	if (!ctx.omitted) {
		const description$1 = resolveDescription(ctx);
		if (description$1) messages.push(description$1, "");
	}
	messages.push(...await renderUsageSection(ctx), "");
	if (ctx.omitted && await hasCommands(ctx)) messages.push(...await renderCommandsSection(ctx), "");
	if (hasPositionalArgs(ctx)) messages.push(...await renderPositionalArgsSection(ctx), "");
	if (hasOptionalArgs(ctx)) messages.push(...await renderOptionalArgsSection(ctx), "");
	const examples = await renderExamplesSection(ctx);
	if (examples.length > 0) messages.push(...examples, "");
	return messages.join("\n");
}
async function renderPositionalArgsSection(ctx) {
	const messages = [];
	messages.push(`${ctx.translate(resolveBuiltInKey("ARGUMENTS"))}:`);
	messages.push(await generatePositionalArgsUsage(ctx));
	return messages;
}
async function renderOptionalArgsSection(ctx) {
	const messages = [];
	messages.push(`${ctx.translate(resolveBuiltInKey("OPTIONS"))}:`);
	messages.push(await generateOptionalArgsUsage(ctx, getOptionalArgsPairs(ctx)));
	return messages;
}
async function renderExamplesSection(ctx) {
	const messages = [];
	const resolvedExamples = await resolveExamples$1(ctx);
	if (resolvedExamples) {
		const examples = resolvedExamples.split("\n").map((example) => example.padStart(ctx.env.leftMargin + example.length));
		messages.push(`${ctx.translate(resolveBuiltInKey("EXAMPLES"))}:`, ...examples);
	}
	return messages;
}
async function renderUsageSection(ctx) {
	const messages = [`${ctx.translate(resolveBuiltInKey("USAGE"))}:`];
	if (ctx.omitted) {
		const defaultCommand = `${resolveEntry(ctx)}${await hasCommands(ctx) ? ` [${resolveSubCommand(ctx)}]` : ""} ${[generateOptionsSymbols(ctx), generatePositionalSymbols(ctx)].filter(Boolean).join(" ")}`;
		messages.push(defaultCommand.padStart(ctx.env.leftMargin + defaultCommand.length));
		if (await hasCommands(ctx)) {
			const commandsUsage = `${resolveEntry(ctx)} <${ctx.translate(resolveBuiltInKey("COMMANDS"))}>`;
			messages.push(commandsUsage.padStart(ctx.env.leftMargin + commandsUsage.length));
		}
	} else {
		const usageStr = `${resolveEntry(ctx)} ${resolveSubCommand(ctx)} ${[generateOptionsSymbols(ctx), generatePositionalSymbols(ctx)].filter(Boolean).join(" ")}`;
		messages.push(usageStr.padStart(ctx.env.leftMargin + usageStr.length));
	}
	return messages;
}
async function renderCommandsSection(ctx) {
	const messages = [`${ctx.translate(resolveBuiltInKey("COMMANDS"))}:`];
	const loadedCommands = await ctx.loadCommands();
	const commandMaxLength = Math.max(...loadedCommands.map((cmd) => (cmd.name || "").length));
	const commandsStr = await Promise.all(loadedCommands.map((cmd) => {
		const key = cmd.name || "";
		const desc = cmd.description || "";
		const command = `${key.padEnd(commandMaxLength + ctx.env.middleMargin)}${desc} `;
		return `${command.padStart(ctx.env.leftMargin + command.length)} `;
	}));
	messages.push(...commandsStr, "", ctx.translate(resolveBuiltInKey("FORMORE")));
	messages.push(...loadedCommands.map((cmd) => {
		const commandHelp = `${ctx.env.name} ${cmd.name} --help`;
		return `${commandHelp.padStart(ctx.env.leftMargin + commandHelp.length)}`;
	}));
	return messages;
}
function resolveEntry(ctx) {
	return ctx.env.name || ctx.translate(resolveBuiltInKey("COMMAND"));
}
function resolveSubCommand(ctx) {
	return ctx.name || ctx.translate(resolveBuiltInKey("SUBCOMMAND"));
}
function resolveDescription(ctx) {
	return ctx.translate("description") || ctx.description || "";
}
async function resolveExamples$1(ctx) {
	const ret = ctx.translate("examples");
	if (ret) return ret;
	const command = ctx.env.subCommands?.get(ctx.name || "");
	return await resolveExamples(ctx, command?.examples);
}
async function hasCommands(ctx) {
	return (await ctx.loadCommands()).length > 1;
}
function hasOptionalArgs(ctx) {
	return !!(ctx.args && Object.values(ctx.args).some((arg) => arg.type !== "positional"));
}
function hasPositionalArgs(ctx) {
	return !!(ctx.args && Object.values(ctx.args).some((arg) => arg.type === "positional"));
}
function hasAllDefaultOptions(ctx) {
	return !!(ctx.args && Object.values(ctx.args).every((arg) => arg.default));
}
function generateOptionsSymbols(ctx) {
	return hasOptionalArgs(ctx) ? hasAllDefaultOptions(ctx) ? `[${ctx.translate(resolveBuiltInKey("OPTIONS"))}]` : `<${ctx.translate(resolveBuiltInKey("OPTIONS"))}>` : "";
}
function makeShortLongOptionPair(schema, name$1, toKebab) {
	let key = `--${toKebab || schema.toKebab ? kebabnize(name$1) : name$1}`;
	if (schema.short) key = `-${schema.short}, ${key}`;
	return key;
}
function getOptionalArgsPairs(ctx) {
	return Object.entries(ctx.args).reduce((acc, [name$1, schema]) => {
		if (schema.type === "positional") return acc;
		let key = makeShortLongOptionPair(schema, name$1, ctx.toKebab);
		if (schema.type !== "boolean") {
			const displayName = ctx.toKebab || schema.toKebab ? kebabnize(name$1) : name$1;
			key = schema.default ? `${key} [${displayName}]` : `${key} <${displayName}>`;
		}
		acc[name$1] = key;
		if (schema.type === "boolean" && schema.negatable && !COMMON_ARGS_KEYS.includes(name$1)) {
			const displayName = ctx.toKebab || schema.toKebab ? kebabnize(name$1) : name$1;
			acc[`no-${name$1}`] = `--no-${displayName}`;
		}
		return acc;
	}, create());
}
const resolveNegatableKey = (key) => key.split("no-")[1];
function resolveNegatableType(key, ctx) {
	return ctx.args[key.startsWith("no-") ? resolveNegatableKey(key) : key].type;
}
function generateDefaultDisplayValue(ctx, schema) {
	return `${ctx.translate(resolveBuiltInKey("DEFAULT"))}: ${schema.default}`;
}
function resolveDisplayValue(ctx, key) {
	if (COMMON_ARGS_KEYS.includes(key)) return "";
	const schema = ctx.args[key];
	if ((schema.type === "boolean" || schema.type === "number" || schema.type === "string" || schema.type === "custom") && schema.default !== void 0) return `(${generateDefaultDisplayValue(ctx, schema)})`;
	if (schema.type === "enum") {
		const _default = schema.default !== void 0 ? generateDefaultDisplayValue(ctx, schema) : "";
		const choices = `${ctx.translate(resolveBuiltInKey("CHOICES"))}: ${schema.choices.join(" | ")}`;
		return `(${_default ? `${_default}, ${choices}` : choices})`;
	}
	return "";
}
async function generateOptionalArgsUsage(ctx, optionsPairs) {
	const optionsMaxLength = Math.max(...Object.entries(optionsPairs).map(([_$1, value$1]) => value$1.length));
	const optionSchemaMaxLength = ctx.env.usageOptionType ? Math.max(...Object.entries(optionsPairs).map(([key]) => resolveNegatableType(key, ctx).length)) : 0;
	return (await Promise.all(Object.entries(optionsPairs).map(([key, value$1]) => {
		let rawDesc = ctx.translate(resolveArgKey(key));
		if (!rawDesc && key.startsWith("no-")) {
			const name$1 = resolveNegatableKey(key);
			const schema = ctx.args[name$1];
			const optionKey = makeShortLongOptionPair(schema, name$1, ctx.toKebab);
			rawDesc = `${ctx.translate(resolveBuiltInKey("NEGATABLE"))} ${optionKey}`;
		}
		const optionsSchema = ctx.env.usageOptionType ? `[${resolveNegatableType(key, ctx)}] ` : "";
		const valueDesc = key.startsWith("no-") ? "" : resolveDisplayValue(ctx, key);
		const desc = `${optionsSchema ? optionsSchema.padEnd(optionSchemaMaxLength + 3) : ""}${rawDesc}`;
		const option = `${value$1.padEnd(optionsMaxLength + ctx.env.middleMargin)}${desc}${valueDesc ? ` ${valueDesc}` : ""}`;
		return `${option.padStart(ctx.env.leftMargin + option.length)}`;
	}))).join("\n");
}
function getPositionalArgs(ctx) {
	return Object.entries(ctx.args).filter(([_$1, schema]) => schema.type === "positional");
}
async function generatePositionalArgsUsage(ctx) {
	const positionals = getPositionalArgs(ctx);
	const argsMaxLength = Math.max(...positionals.map(([name$1]) => name$1.length));
	return (await Promise.all(positionals.map(([name$1]) => {
		const desc = ctx.translate(resolveArgKey(name$1)) || ctx.args[name$1].description || "";
		const arg = `${name$1.padEnd(argsMaxLength + ctx.env.middleMargin)} ${desc}`;
		return `${arg.padStart(ctx.env.leftMargin + arg.length)}`;
	}))).join("\n");
}
function generatePositionalSymbols(ctx) {
	return hasPositionalArgs(ctx) ? getPositionalArgs(ctx).map(([name$1]) => `<${name$1}>`).join(" ") : "";
}
function renderValidationErrors(_ctx, error) {
	const messages = [];
	for (const err of error.errors) messages.push(err.message);
	return Promise.resolve(messages.join("\n"));
}
const HYPHEN_CHAR = "-";
const HYPHEN_CODE = HYPHEN_CHAR.codePointAt(0);
const EQUAL_CHAR = "=";
const EQUAL_CODE = EQUAL_CHAR.codePointAt(0);
const TERMINATOR = "--";
const SHORT_OPTION_PREFIX = HYPHEN_CHAR;
const LONG_OPTION_PREFIX = "--";
function parseArgs(args, options = {}) {
	const { allowCompatible = false } = options;
	const tokens = [];
	const remainings = [...args];
	let index = -1;
	let groupCount = 0;
	let hasShortValueSeparator = false;
	while (remainings.length > 0) {
		const arg = remainings.shift();
		if (arg == void 0) break;
		const nextArg = remainings[0];
		if (groupCount > 0) groupCount--;
		else index++;
		if (arg === TERMINATOR) {
			tokens.push({
				kind: "option-terminator",
				index
			});
			const mapped = remainings.map((arg$1) => {
				return {
					kind: "positional",
					index: ++index,
					value: arg$1
				};
			});
			tokens.push(...mapped);
			break;
		}
		if (isShortOption(arg)) {
			const shortOption = arg.charAt(1);
			let value$1;
			let inlineValue;
			if (groupCount) {
				tokens.push({
					kind: "option",
					name: shortOption,
					rawName: arg,
					index,
					value: value$1,
					inlineValue
				});
				if (groupCount === 1 && hasOptionValue(nextArg)) {
					value$1 = remainings.shift();
					if (hasShortValueSeparator) {
						inlineValue = true;
						hasShortValueSeparator = false;
					}
					tokens.push({
						kind: "option",
						index,
						value: value$1,
						inlineValue
					});
				}
			} else tokens.push({
				kind: "option",
				name: shortOption,
				rawName: arg,
				index,
				value: value$1,
				inlineValue
			});
			if (value$1 != null) ++index;
			continue;
		}
		if (isShortOptionGroup(arg)) {
			const expanded = [];
			let shortValue = "";
			for (let i = 1; i < arg.length; i++) {
				const shortableOption = arg.charAt(i);
				if (hasShortValueSeparator) shortValue += shortableOption;
				else if (!allowCompatible && shortableOption.codePointAt(0) === EQUAL_CODE) hasShortValueSeparator = true;
				else expanded.push(`${SHORT_OPTION_PREFIX}${shortableOption}`);
			}
			if (shortValue) expanded.push(shortValue);
			remainings.unshift(...expanded);
			groupCount = expanded.length;
			continue;
		}
		if (isLongOption(arg)) {
			const longOption = arg.slice(2);
			tokens.push({
				kind: "option",
				name: longOption,
				rawName: arg,
				index,
				value: void 0,
				inlineValue: void 0
			});
			continue;
		}
		if (isLongOptionAndValue(arg)) {
			const equalIndex = arg.indexOf(EQUAL_CHAR);
			const longOption = arg.slice(2, equalIndex);
			const value$1 = arg.slice(equalIndex + 1);
			tokens.push({
				kind: "option",
				name: longOption,
				rawName: `${LONG_OPTION_PREFIX}${longOption}`,
				index,
				value: value$1,
				inlineValue: true
			});
			continue;
		}
		tokens.push({
			kind: "positional",
			index,
			value: arg
		});
	}
	return tokens;
}
function isShortOption(arg) {
	return arg.length === 2 && arg.codePointAt(0) === HYPHEN_CODE && arg.codePointAt(1) !== HYPHEN_CODE;
}
function isShortOptionGroup(arg) {
	if (arg.length <= 2) return false;
	if (arg.codePointAt(0) !== HYPHEN_CODE) return false;
	if (arg.codePointAt(1) === HYPHEN_CODE) return false;
	return true;
}
function isLongOption(arg) {
	return hasLongOptionPrefix(arg) && !arg.includes(EQUAL_CHAR, 3);
}
function isLongOptionAndValue(arg) {
	return hasLongOptionPrefix(arg) && arg.includes(EQUAL_CHAR, 3);
}
function hasLongOptionPrefix(arg) {
	return arg.length > 2 && ~arg.indexOf(LONG_OPTION_PREFIX);
}
function hasOptionValue(value$1) {
	return !(value$1 == null) && value$1.codePointAt(0) !== HYPHEN_CODE;
}
const SKIP_POSITIONAL_DEFAULT = -1;
function resolveArgs(args, tokens, { shortGrouping = false, skipPositional = SKIP_POSITIONAL_DEFAULT, toKebab = false } = {}) {
	const skipPositionalIndex = typeof skipPositional === "number" ? Math.max(skipPositional, SKIP_POSITIONAL_DEFAULT) : SKIP_POSITIONAL_DEFAULT;
	const rest = [];
	const optionTokens = [];
	const positionalTokens = [];
	let currentLongOption;
	let currentShortOption;
	const expandableShortOptions = [];
	function toShortValue() {
		if (expandableShortOptions.length === 0) return void 0;
		else {
			const value$1 = expandableShortOptions.map((token) => token.name).join("");
			expandableShortOptions.length = 0;
			return value$1;
		}
	}
	function applyLongOptionValue(value$1 = void 0) {
		if (currentLongOption) {
			currentLongOption.value = value$1;
			optionTokens.push({ ...currentLongOption });
			currentLongOption = void 0;
		}
	}
	function applyShortOptionValue(value$1 = void 0) {
		if (currentShortOption) {
			currentShortOption.value = value$1 || toShortValue();
			optionTokens.push({ ...currentShortOption });
			currentShortOption = void 0;
		}
	}
	const schemas = Object.values(args);
	let terminated = false;
	for (let i = 0; i < tokens.length; i++) {
		const token = tokens[i];
		if (token.kind === "positional") {
			if (terminated && token.value) {
				rest.push(token.value);
				continue;
			}
			if (currentShortOption) {
				if (schemas.find((schema) => schema.short === currentShortOption.name && schema.type === "boolean")) positionalTokens.push({ ...token });
			} else if (currentLongOption) {
				if (args[currentLongOption.name]?.type === "boolean") positionalTokens.push({ ...token });
			} else positionalTokens.push({ ...token });
			applyLongOptionValue(token.value);
			applyShortOptionValue(token.value);
		} else if (token.kind === "option") if (token.rawName) {
			if (hasLongOptionPrefix(token.rawName)) {
				applyLongOptionValue();
				if (token.inlineValue) optionTokens.push({ ...token });
				else currentLongOption = { ...token };
				applyShortOptionValue();
			} else if (isShortOption(token.rawName)) if (currentShortOption) {
				if (currentShortOption.index === token.index) if (shortGrouping) {
					currentShortOption.value = token.value;
					optionTokens.push({ ...currentShortOption });
					currentShortOption = { ...token };
				} else expandableShortOptions.push({ ...token });
				else {
					currentShortOption.value = toShortValue();
					optionTokens.push({ ...currentShortOption });
					currentShortOption = { ...token };
				}
				applyLongOptionValue();
			} else {
				currentShortOption = { ...token };
				applyLongOptionValue();
			}
		} else {
			if (currentShortOption && currentShortOption.index == token.index && token.inlineValue) {
				currentShortOption.value = token.value;
				optionTokens.push({ ...currentShortOption });
				currentShortOption = void 0;
			}
			applyLongOptionValue();
		}
		else {
			if (token.kind === "option-terminator") terminated = true;
			applyLongOptionValue();
			applyShortOptionValue();
		}
	}
	applyLongOptionValue();
	applyShortOptionValue();
	const values = Object.create(null);
	const errors = [];
	function checkTokenName(option, schema, token) {
		return token.name === (schema.type === "boolean" ? schema.negatable && token.name?.startsWith("no-") ? `no-${option}` : option : option);
	}
	const positionalItemCount = tokens.filter((token) => token.kind === "positional").length;
	function getPositionalSkipIndex() {
		return Math.min(skipPositionalIndex, positionalItemCount);
	}
	let positionalsCount = 0;
	for (const [rawArg, schema] of Object.entries(args)) {
		const arg = toKebab || schema.toKebab ? kebabnize(rawArg) : rawArg;
		if (schema.required) {
			if (!optionTokens.find((token) => {
				return schema.short && token.name === schema.short || token.rawName && hasLongOptionPrefix(token.rawName) && token.name === arg;
			})) {
				errors.push(createRequireError(arg, schema));
				continue;
			}
		}
		if (schema.type === "positional") {
			if (skipPositionalIndex > SKIP_POSITIONAL_DEFAULT) while (positionalsCount <= getPositionalSkipIndex()) positionalsCount++;
			const positional = positionalTokens[positionalsCount];
			if (positional != null) values[rawArg] = positional.value;
			else errors.push(createRequireError(arg, schema));
			positionalsCount++;
			continue;
		}
		for (let i = 0; i < optionTokens.length; i++) {
			const token = optionTokens[i];
			if (checkTokenName(arg, schema, token) && token.rawName != void 0 && hasLongOptionPrefix(token.rawName) || schema.short === token.name && token.rawName != void 0 && isShortOption(token.rawName)) {
				const invalid = validateRequire(token, arg, schema);
				if (invalid) {
					errors.push(invalid);
					continue;
				}
				if (schema.type === "boolean") token.value = void 0;
				const [parsedValue, error] = parse(token, arg, schema);
				if (error) errors.push(error);
				else if (schema.multiple) {
					values[rawArg] ||= [];
					values[rawArg].push(parsedValue);
				} else values[rawArg] = parsedValue;
			}
		}
		if (values[rawArg] == null && schema.default != null) values[rawArg] = schema.default;
	}
	return {
		values,
		positionals: positionalTokens.map((token) => token.value),
		rest,
		error: errors.length > 0 ? new AggregateError(errors) : void 0
	};
}
function parse(token, option, schema) {
	switch (schema.type) {
		case "string": return typeof token.value === "string" ? [token.value || schema.default, void 0] : [void 0, createTypeError(option, schema)];
		case "boolean": return token.value ? [token.value || schema.default, void 0] : [!(schema.negatable && token.name.startsWith("no-")), void 0];
		case "number":
			if (!isNumeric(token.value)) return [void 0, createTypeError(option, schema)];
			return token.value ? [+token.value, void 0] : [+(schema.default || ""), void 0];
		case "enum":
			if (schema.choices && !schema.choices.includes(token.value)) return [void 0, new ArgResolveError(`Optional argument '--${option}' ${schema.short ? `or '-${schema.short}' ` : ""}should be chosen from '${schema.type}' [${schema.choices.map((c) => JSON.stringify(c)).join(", ")}] values`, option, "type", schema)];
			return [token.value || schema.default, void 0];
		case "custom":
			if (typeof schema.parse !== "function") throw new TypeError(`argument '${option}' should have a 'parse' function`);
			try {
				return [schema.parse(token.value || String(schema.default || "")), void 0];
			} catch (error) {
				return [void 0, error];
			}
		default: throw new Error(`Unsupported argument type '${schema.type}' for option '${option}'`);
	}
}
function createRequireError(option, schema) {
	return new ArgResolveError(schema.type === "positional" ? `Positional argument '${option}' is required` : `Optional argument '--${option}' ${schema.short ? `or '-${schema.short}' ` : ""}is required`, option, "required", schema);
}
var ArgResolveError = class extends Error {
	name;
	schema;
	type;
	constructor(message, name$1, type, schema) {
		super(message);
		this.name = name$1;
		this.type = type;
		this.schema = schema;
	}
};
function validateRequire(token, option, schema) {
	if (schema.required && schema.type !== "boolean" && !token.value) return createRequireError(option, schema);
}
function isNumeric(str$1) {
	return str$1.trim() !== "" && !isNaN(str$1);
}
function createTypeError(option, schema) {
	return new ArgResolveError(`Optional argument '--${option}' ${schema.short ? `or '-${schema.short}' ` : ""}should be '${schema.type}'`, option, "type", schema);
}
async function cli(argv, entry, options = {}) {
	const cliOptions = resolveCliOptions(options, entry);
	const tokens = parseArgs(argv);
	const subCommand = getSubCommand(tokens);
	const { commandName: name$1, command, callMode } = await resolveCommand(subCommand, entry, cliOptions);
	if (!command) throw new Error(`Command not found: ${name$1 || ""}`);
	const args = resolveArguments(getCommandArgs(command));
	const { values, positionals, rest, error } = resolveArgs(args, tokens, {
		shortGrouping: true,
		toKebab: command.toKebab,
		skipPositional: cliOptions.subCommands.size > 0 ? 0 : -1
	});
	const ctx = await createCommandContext({
		args,
		values,
		positionals,
		rest,
		argv,
		tokens,
		omitted: !subCommand,
		callMode,
		command,
		cliOptions
	});
	if (values.version) {
		showVersion(ctx);
		return;
	}
	const usageBuffer = [];
	const header = await showHeader(ctx);
	if (header) usageBuffer.push(header);
	if (values.help) {
		const usage = await showUsage(ctx);
		if (usage) usageBuffer.push(usage);
		return usageBuffer.join("\n");
	}
	if (error) {
		await showValidationErrors(ctx, error);
		return;
	}
	await executeCommand(command, ctx, name$1 || "");
}
function getCommandArgs(cmd) {
	if (isLazyCommand(cmd)) return cmd.args || create();
	else if (typeof cmd === "object") return cmd.args || create();
	else return create();
}
function resolveArguments(args) {
	return Object.assign(create(), args, COMMON_ARGS);
}
function resolveCliOptions(options, entry) {
	const subCommands$1 = new Map(options.subCommands);
	if (options.subCommands) {
		if (isLazyCommand(entry)) subCommands$1.set(entry.commandName, entry);
		else if (typeof entry === "object" && entry.name) subCommands$1.set(entry.name, entry);
	}
	return Object.assign(create(), COMMAND_OPTIONS_DEFAULT, options, { subCommands: subCommands$1 });
}
function getSubCommand(tokens) {
	const firstToken = tokens[0];
	return firstToken && firstToken.kind === "positional" && firstToken.index === 0 && firstToken.value ? firstToken.value : "";
}
async function showUsage(ctx) {
	if (ctx.env.renderUsage === null) return;
	const usage = await (ctx.env.renderUsage || renderUsage)(ctx);
	if (usage) {
		ctx.log(usage);
		return usage;
	}
}
function showVersion(ctx) {
	ctx.log(ctx.env.version);
}
async function showHeader(ctx) {
	if (ctx.env.renderHeader === null) return;
	const header = await (ctx.env.renderHeader || renderHeader)(ctx);
	if (header) {
		ctx.log(header);
		ctx.log();
		return header;
	}
}
async function showValidationErrors(ctx, error) {
	if (ctx.env.renderValidationErrors === null) return;
	const render = ctx.env.renderValidationErrors || renderValidationErrors;
	ctx.log(await render(ctx, error));
}
const CANNOT_RESOLVE_COMMAND = { callMode: "unexpected" };
async function resolveCommand(sub, entry, options) {
	const omitted = !sub;
	async function doResolveCommand() {
		if (typeof entry === "function") if ("commandName" in entry && entry.commandName) return {
			commandName: entry.commandName,
			command: entry,
			callMode: "entry"
		};
		else return {
			command: { run: entry },
			callMode: "entry"
		};
		else if (typeof entry === "object") return {
			commandName: resolveEntryName(entry),
			command: entry,
			callMode: "entry"
		};
		else return CANNOT_RESOLVE_COMMAND;
	}
	if (omitted || options.subCommands?.size === 0) return doResolveCommand();
	const cmd = options.subCommands?.get(sub);
	if (cmd == null) return {
		commandName: sub,
		callMode: "unexpected"
	};
	if (isLazyCommand(cmd) && cmd.commandName == null) cmd.commandName = sub;
	else if (typeof cmd === "object" && cmd.name == null) cmd.name = sub;
	return {
		commandName: sub,
		command: cmd,
		callMode: "subCommand"
	};
}
function resolveEntryName(entry) {
	return entry.name || ANONYMOUS_COMMAND_NAME;
}
async function executeCommand(cmd, ctx, name$1) {
	const resolved = isLazyCommand(cmd) ? await resolveLazyCommand(cmd, name$1, true) : cmd;
	if (resolved.run == null) throw new Error(`'run' not found on Command \`${name$1}\``);
	await resolved.run(ctx);
}
var import_picocolors$2 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
function extractExplicitArgs(tokens) {
	const explicit = {};
	for (const token of tokens) if (typeof token === "object" && token !== null) {
		const t = token;
		if (t.kind === "option" && typeof t.name === "string") explicit[t.name] = true;
	}
	return explicit;
}
function getConfigSearchPaths() {
	return [join(process$1.cwd(), ".ccusage"), ...toArray(getClaudePaths())].map((dir) => join(dir, CONFIG_FILE_NAME));
}
function validateConfigJson(data) {
	if (typeof data !== "object" || data === null) return false;
	const config = data;
	if (config.$schema != null && typeof config.$schema !== "string") return false;
	if (config.defaults != null && (typeof config.defaults !== "object" || config.defaults === null)) return false;
	if (config.commands != null && (typeof config.commands !== "object" || config.commands === null)) return false;
	return true;
}
function loadConfigFile(filePath, debug = false) {
	if (!existsSync(filePath)) {
		if (debug) logger.info(`  • Checking: ${filePath} (not found)`);
		return;
	}
	return pipe(try_({
		try: () => {
			const content = readFileSync(filePath, "utf-8");
			const data = JSON.parse(content);
			if (!validateConfigJson(data)) throw new Error("Invalid configuration structure");
			data.source = filePath;
			return data;
		},
		catch: (error) => error
	})(), inspect(() => {
		logger.debug(`Parsed configuration file: ${filePath}`);
		if (debug) logger.info(`  • Checking: ${filePath} (found ✓)`);
	}), inspectError((error) => {
		const errorMessage = error instanceof Error ? error.message : String(error);
		logger.warn(`Error parsing configuration file at ${filePath}: ${errorMessage}`);
		if (debug) logger.info(`  • Checking: ${filePath} (error: ${errorMessage})`);
	}), unwrap(void 0));
}
function loadConfig(configPath, debug = false) {
	if (debug) logger.info("Debug mode enabled - showing config loading details\n");
	if (configPath != null) {
		if (debug) {
			logger.info("Using specified config file:");
			logger.info(`  • Path: ${configPath}`);
		}
		const config = loadConfigFile(configPath, debug);
		if (config == null) logger.warn(`Configuration file not found or invalid: ${configPath}`);
		else if (debug) {
			logger.info("");
			logger.info(`Loaded config from: ${configPath}`);
			logger.info(`  • Schema: ${config.$schema ?? "none"}`);
			logger.info(`  • Has defaults: ${config.defaults != null ? "yes" : "no"}${config.defaults != null ? ` (${Object.keys(config.defaults).length} options)` : ""}`);
			logger.info(`  • Has command configs: ${config.commands != null ? "yes" : "no"}${config.commands != null ? ` (${Object.keys(config.commands).join(", ")})` : ""}`);
		}
		return config;
	}
	if (debug) logger.info("Searching for config files:");
	for (const searchPath of getConfigSearchPaths()) {
		const config = loadConfigFile(searchPath, debug);
		if (config != null) {
			if (debug) {
				logger.info("");
				logger.info(`Loaded config from: ${searchPath}`);
				logger.info(`  • Schema: ${config.$schema ?? "none"}`);
				logger.info(`  • Has defaults: ${config.defaults != null ? "yes" : "no"}${config.defaults != null ? ` (${Object.keys(config.defaults).length} options)` : ""}`);
				logger.info(`  • Has command configs: ${config.commands != null ? "yes" : "no"}${config.commands != null ? ` (${Object.keys(config.commands).join(", ")})` : ""}`);
			}
			return config;
		}
	}
	logger.debug("No valid configuration file found");
	if (debug) {
		logger.info("");
		logger.info("No valid configuration file found");
	}
}
function mergeConfigWithArgs(ctx, config, debug = false) {
	if (config == null) {
		if (debug) {
			logger.info("");
			logger.info(`No config file loaded, using CLI args only for '${ctx.name ?? "unknown"}' command`);
		}
		return ctx.values;
	}
	const merged = {};
	const commandName = ctx.name;
	const sources = {};
	if (config.defaults != null) for (const [key, value$1] of Object.entries(config.defaults)) {
		merged[key] = value$1;
		sources[key] = "defaults";
	}
	if (commandName != null && config.commands?.[commandName] != null) for (const [key, value$1] of Object.entries(config.commands[commandName])) {
		merged[key] = value$1;
		sources[key] = "command config";
	}
	const explicit = extractExplicitArgs(ctx.tokens);
	for (const [key, value$1] of Object.entries(ctx.values)) if (value$1 != null && explicit[key] === true) {
		merged[key] = value$1;
		sources[key] = "CLI";
	}
	logger.debug(`Merged config for ${commandName ?? "unknown"}:`, merged);
	if (debug) {
		logger.info("");
		logger.info(`Merging options for '${commandName ?? "unknown"}' command:`);
		const bySource = {
			defaults: [],
			"command config": [],
			CLI: []
		};
		for (const [key, source] of Object.entries(sources)) if (bySource[source] != null) bySource[source].push(`${key}=${JSON.stringify(merged[key])}`);
		if (bySource.defaults.length > 0) logger.info(`  • From defaults: ${bySource.defaults.join(", ")}`);
		if (bySource["command config"].length > 0) logger.info(`  • From command config: ${bySource["command config"].join(", ")}`);
		if (bySource.CLI.length > 0) logger.info(`  • From CLI args: ${bySource.CLI.join(", ")}`);
		logger.info("  • Final merged options: {");
		for (const [key, value$1] of Object.entries(merged)) {
			const source = sources[key] ?? "unknown";
			logger.info(`      ${key}: ${JSON.stringify(value$1)} (from ${source}),`);
		}
		logger.info("    }");
	}
	return merged;
}
const getContext = (raw) => ({
	start: process$1.hrtime.bigint(),
	command: raw.map((part) => getCommandPart(stripVTControlCharacters(part))).join(" "),
	state: {
		stdout: "",
		stderr: "",
		output: ""
	}
});
const getCommandPart = (part) => /[^\w./-]/.test(part) ? `'${part.replaceAll("'", "'\\''")}'` : part;
const getOptions = ({ stdin: stdin$2, stdout: stdout$1, stderr, stdio = [
	stdin$2,
	stdout$1,
	stderr
], env: envOption, preferLocal, cwd: cwdOption = ".", ...options }) => {
	const cwd = cwdOption instanceof URL ? fileURLToPath(cwdOption) : path.resolve(cwdOption);
	const env = envOption ? {
		...process$1.env,
		...envOption
	} : void 0;
	const input = stdio[0]?.string;
	return {
		...options,
		input,
		stdio: input === void 0 ? stdio : ["pipe", ...stdio.slice(1)],
		env: preferLocal ? addLocalPath(env ?? process$1.env, cwd) : env,
		cwd
	};
};
const addLocalPath = ({ Path = "", PATH = Path, ...env }, cwd) => {
	const pathParts = PATH.split(path.delimiter);
	const localPaths = getLocalPaths([], path.resolve(cwd)).map((localPath) => path.join(localPath, "node_modules/.bin")).filter((localPath) => !pathParts.includes(localPath));
	return {
		...env,
		PATH: [...localPaths, PATH].filter(Boolean).join(path.delimiter)
	};
};
const getLocalPaths = (localPaths, localPath) => localPaths.at(-1) === localPath ? localPaths : getLocalPaths([...localPaths, localPath], path.resolve(localPath, ".."));
const applyForceShell = async (file, commandArguments, options) => await shouldForceShell(file, options) ? [
	escapeFile(file),
	commandArguments.map((argument) => escapeArgument(argument)),
	{
		...options,
		shell: true
	}
] : [
	file,
	commandArguments,
	options
];
const shouldForceShell = async (file, { shell, cwd, env = process$1.env }) => process$1.platform === "win32" && !shell && !await isExe(file, cwd, env);
const isExe = (file, cwd, { Path = "", PATH = Path }) => exeExtensions.some((extension) => file.toLowerCase().endsWith(extension)) || mIsExe(file, cwd, PATH);
const EXE_MEMO = {};
const memoize = (function_) => (...arguments_) => EXE_MEMO[arguments_.join("\0")] ??= function_(...arguments_);
const access = memoize(a.access);
const mIsExe = memoize(async (file, cwd, PATH) => {
	const parts = PATH.split(path.delimiter).filter(Boolean).map((part) => part.replace(/^"(.*)"$/, "$1"));
	try {
		await Promise.any([cwd, ...parts].flatMap((part) => exeExtensions.map((extension) => access(`${path.resolve(part, file)}${extension}`))));
	} catch {
		return false;
	}
	return true;
});
const exeExtensions = [".exe", ".com"];
const escapeArgument = (argument) => escapeFile(escapeFile(`"${argument.replaceAll(/(\\*)"/g, "$1$1\\\"").replace(/(\\*)$/, "$1$1")}"`));
const escapeFile = (file) => file.replaceAll(/([()\][%!^"`<>&|;, *?])/g, "^$1");
const getResult = async (nodeChildProcess, { input }, context) => {
	const instance = await nodeChildProcess;
	if (input !== void 0) instance.stdin.end(input);
	const onClose = once(instance, "close");
	try {
		await Promise.race([onClose, ...instance.stdio.filter(Boolean).map((stream) => onStreamError(stream))]);
		checkFailure(context, getErrorOutput(instance));
		return getOutputs(context);
	} catch (error) {
		await Promise.allSettled([onClose]);
		throw getResultError(error, instance, context);
	}
};
const onStreamError = async (stream) => {
	for await (const [error] of on(stream, "error")) if (!["ERR_STREAM_PREMATURE_CLOSE", "EPIPE"].includes(error?.code)) throw error;
};
const checkFailure = ({ command }, { exitCode, signalName }) => {
	if (signalName !== void 0) throw new SubprocessError(`Command was terminated with ${signalName}: ${command}`);
	if (exitCode !== void 0) throw new SubprocessError(`Command failed with exit code ${exitCode}: ${command}`);
};
const getResultError = (error, instance, context) => Object.assign(getErrorInstance(error, context), getErrorOutput(instance), getOutputs(context));
const getErrorInstance = (error, { command }) => error instanceof SubprocessError ? error : new SubprocessError(`Command failed: ${command}`, { cause: error });
var SubprocessError = class extends Error {
	name = "SubprocessError";
};
const getErrorOutput = ({ exitCode, signalCode }) => ({
	...exitCode < 1 ? {} : { exitCode },
	...signalCode === null ? {} : { signalName: signalCode }
});
const getOutputs = ({ state: { stdout: stdout$1, stderr, output }, command, start }) => ({
	stdout: getOutput(stdout$1),
	stderr: getOutput(stderr),
	output: getOutput(output),
	command,
	durationMs: Number(process$1.hrtime.bigint() - start) / 1e6
});
const getOutput = (output) => output.at(-1) === "\n" ? output.slice(0, output.at(-2) === "\r" ? -2 : -1) : output;
const spawnSubprocess = async (file, commandArguments, options, context) => {
	try {
		if (["node", "node.exe"].includes(file.toLowerCase())) {
			file = process$1.execPath;
			commandArguments = [...process$1.execArgv.filter((flag) => !flag.startsWith("--inspect")), ...commandArguments];
		}
		[file, commandArguments, options] = await applyForceShell(file, commandArguments, options);
		[file, commandArguments, options] = concatenateShell(file, commandArguments, options);
		const instance = spawn(file, commandArguments, options);
		bufferOutput(instance.stdout, context, "stdout");
		bufferOutput(instance.stderr, context, "stderr");
		instance.once("error", () => {});
		await once(instance, "spawn");
		return instance;
	} catch (error) {
		throw getResultError(error, {}, context);
	}
};
const concatenateShell = (file, commandArguments, options) => options.shell && commandArguments.length > 0 ? [
	[file, ...commandArguments].join(" "),
	[],
	options
] : [
	file,
	commandArguments,
	options
];
const bufferOutput = (stream, { state }, streamName) => {
	if (stream) {
		stream.setEncoding("utf8");
		if (!state.isIterating) {
			state.isIterating = false;
			stream.on("data", (chunk) => {
				state[streamName] += chunk;
				state.output += chunk;
			});
		}
	}
};
const handlePipe = async (subprocesses) => {
	const [[from, to]] = await Promise.all([Promise.allSettled(subprocesses), pipeStreams(subprocesses)]);
	if (to.reason) {
		to.reason.pipedFrom = from.reason ?? from.value;
		throw to.reason;
	}
	if (from.reason) throw from.reason;
	return {
		...to.value,
		pipedFrom: from.value
	};
};
const pipeStreams = async (subprocesses) => {
	try {
		const [{ stdout: stdout$1 }, { stdin: stdin$2 }] = await Promise.all(subprocesses.map(({ nodeChildProcess }) => nodeChildProcess));
		if (stdin$2 === null) throw new Error("The \"stdin\" option must be set on the first \"spawn()\" call in the pipeline.");
		if (stdout$1 === null) throw new Error("The \"stdout\" option must be set on the last \"spawn()\" call in the pipeline.");
		pipeline(stdout$1, stdin$2).catch(() => {});
	} catch (error) {
		await Promise.allSettled(subprocesses.map(({ nodeChildProcess }) => closeStdin(nodeChildProcess)));
		throw error;
	}
};
const closeStdin = async (nodeChildProcess) => {
	const { stdin: stdin$2 } = await nodeChildProcess;
	stdin$2.end();
};
const lineIterator = async function* (subprocess, { state }, streamName) {
	if (state.isIterating === false) throw new Error(`The subprocess must be iterated right away, for example:
	for await (const line of spawn(...)) { ... }`);
	state.isIterating = true;
	try {
		const { [streamName]: stream } = await subprocess.nodeChildProcess;
		if (!stream) return;
		handleErrors(subprocess);
		yield* readline.createInterface({ input: stream });
	} finally {
		await subprocess;
	}
};
const handleErrors = async (subprocess) => {
	try {
		await subprocess;
	} catch {}
};
const combineAsyncIterators = async function* (...iterators) {
	try {
		let promises = [];
		while (iterators.length > 0) {
			promises = iterators.map((iterator$1, index$1) => promises[index$1] ?? getNext(iterator$1));
			const [{ value: value$1, done }, index] = await Promise.race(promises.map((promise, index$1) => Promise.all([promise, index$1])));
			const [iterator] = iterators.splice(index, 1);
			promises.splice(index, 1);
			if (!done) {
				iterators.push(iterator);
				yield value$1;
			}
		}
	} finally {
		await Promise.all(iterators.map((iterator) => iterator.return()));
	}
};
const getNext = async (iterator) => {
	try {
		return await iterator.next();
	} catch (error) {
		await iterator.throw(error);
	}
};
function spawn$1(file, second, third, previous) {
	const [commandArguments = [], options = {}] = Array.isArray(second) ? [second, third] : [[], second];
	const context = getContext([file, ...commandArguments]);
	const spawnOptions = getOptions(options);
	const nodeChildProcess = spawnSubprocess(file, commandArguments, spawnOptions, context);
	let subprocess = getResult(nodeChildProcess, spawnOptions, context);
	Object.assign(subprocess, { nodeChildProcess });
	subprocess = previous ? handlePipe([previous, subprocess]) : subprocess;
	const stdout$1 = lineIterator(subprocess, context, "stdout");
	const stderr = lineIterator(subprocess, context, "stderr");
	return Object.assign(subprocess, {
		nodeChildProcess,
		stdout: stdout$1,
		stderr,
		[Symbol.asyncIterator]: () => combineAsyncIterators(stdout$1, stderr),
		pipe: (file$1, second$1, third$1) => spawn$1(file$1, second$1, third$1, subprocess)
	});
}
async function processWithJq(jsonData, jqCommand) {
	const jsonString = JSON.stringify(jsonData);
	return try_({
		try: async () => {
			return (await spawn$1("jq", [jqCommand], { stdin: { string: jsonString } })).output.trim();
		},
		catch: (error) => {
			if (error instanceof Error) {
				if (error.message.includes("ENOENT") || error.message.includes("not found")) return /* @__PURE__ */ new Error("jq command not found. Please install jq to use the --jq option.");
				return /* @__PURE__ */ new Error(`jq processing failed: ${error.message}`);
			}
			return /* @__PURE__ */ new Error("Unknown error during jq processing");
		}
	})();
}
function parseDateArg(value$1) {
	return parse$1(filterDateSchema, value$1);
}
const sharedArgs = {
	since: {
		type: "custom",
		short: "s",
		description: "Filter from date (YYYYMMDD format)",
		parse: parseDateArg
	},
	until: {
		type: "custom",
		short: "u",
		description: "Filter until date (YYYYMMDD format)",
		parse: parseDateArg
	},
	json: {
		type: "boolean",
		short: "j",
		description: "Output in JSON format",
		default: false
	},
	mode: {
		type: "enum",
		short: "m",
		description: "Cost calculation mode: auto (use costUSD if exists, otherwise calculate), calculate (always calculate), display (always use costUSD)",
		default: "auto",
		choices: CostModes
	},
	debug: {
		type: "boolean",
		short: "d",
		description: "Show pricing mismatch information for debugging",
		default: false
	},
	debugSamples: {
		type: "number",
		description: "Number of sample discrepancies to show in debug output (default: 5)",
		default: 5
	},
	order: {
		type: "enum",
		short: "o",
		description: "Sort order: desc (newest first) or asc (oldest first)",
		default: "asc",
		choices: SortOrders
	},
	breakdown: {
		type: "boolean",
		short: "b",
		description: "Show per-model cost breakdown",
		default: false
	},
	offline: {
		type: "boolean",
		negatable: true,
		short: "O",
		description: "Use cached pricing data for Claude models instead of fetching from API",
		default: false
	},
	color: {
		type: "boolean",
		description: "Enable colored output (default: auto). FORCE_COLOR=1 has the same effect."
	},
	noColor: {
		type: "boolean",
		description: "Disable colored output (default: auto). NO_COLOR=1 has the same effect."
	},
	timezone: {
		type: "string",
		short: "z",
		description: "Timezone for date grouping (e.g., UTC, America/New_York, Asia/Tokyo). Default: system timezone"
	},
	locale: {
		type: "string",
		short: "l",
		description: "Locale for date/time formatting (e.g., en-US, ja-JP, de-DE)",
		default: DEFAULT_LOCALE
	},
	jq: {
		type: "string",
		short: "q",
		description: "Process JSON output with jq command (requires jq binary, implies --json)"
	},
	config: {
		type: "string",
		description: "Path to configuration file (default: auto-discovery)"
	},
	compact: {
		type: "boolean",
		description: "Force compact mode for narrow displays (better for screenshots)",
		default: false
	}
};
const sharedCommandConfig = {
	args: sharedArgs,
	toKebab: true
};
function formatBlockTime(block, compact = false, locale) {
	const start = compact ? block.startTime.toLocaleString(locale, {
		month: "2-digit",
		day: "2-digit",
		hour: "2-digit",
		minute: "2-digit"
	}) : block.startTime.toLocaleString(locale);
	if (block.isGap ?? false) {
		const end = compact ? block.endTime.toLocaleString(locale, {
			hour: "2-digit",
			minute: "2-digit"
		}) : block.endTime.toLocaleString(locale);
		const duration$1 = Math.round((block.endTime.getTime() - block.startTime.getTime()) / (1e3 * 60 * 60));
		return compact ? `${start}-${end}\n(${duration$1}h gap)` : `${start} - ${end} (${duration$1}h gap)`;
	}
	const duration = block.actualEndTime != null ? Math.round((block.actualEndTime.getTime() - block.startTime.getTime()) / (1e3 * 60)) : 0;
	if (block.isActive) {
		const now = /* @__PURE__ */ new Date();
		const elapsed = Math.round((now.getTime() - block.startTime.getTime()) / (1e3 * 60));
		const remaining = Math.round((block.endTime.getTime() - now.getTime()) / (1e3 * 60));
		const elapsedHours = Math.floor(elapsed / 60);
		const elapsedMins = elapsed % 60;
		const remainingHours = Math.floor(remaining / 60);
		const remainingMins = remaining % 60;
		if (compact) return `${start}\n(${elapsedHours}h${elapsedMins}m/${remainingHours}h${remainingMins}m)`;
		return `${start} (${elapsedHours}h ${elapsedMins}m elapsed, ${remainingHours}h ${remainingMins}m remaining)`;
	}
	const hours = Math.floor(duration / 60);
	const mins = duration % 60;
	if (compact) return hours > 0 ? `${start}\n(${hours}h${mins}m)` : `${start}\n(${mins}m)`;
	if (hours > 0) return `${start} (${hours}h ${mins}m)`;
	return `${start} (${mins}m)`;
}
function formatModels(models) {
	if (models.length === 0) return "-";
	return formatModelsDisplayMultiline(models);
}
function parseTokenLimit(value$1, maxFromAll) {
	if (value$1 == null || value$1 === "" || value$1 === "max") return maxFromAll > 0 ? maxFromAll : void 0;
	const limit = Number.parseInt(value$1, 10);
	return Number.isNaN(limit) ? void 0 : limit;
}
const blocksCommand = define({
	name: "blocks",
	description: "Show usage report grouped by session billing blocks",
	args: {
		...sharedCommandConfig.args,
		active: {
			type: "boolean",
			short: "a",
			description: "Show only active block with projections",
			default: false
		},
		recent: {
			type: "boolean",
			short: "r",
			description: `Show blocks from last ${DEFAULT_RECENT_DAYS} days (including active)`,
			default: false
		},
		tokenLimit: {
			type: "string",
			short: "t",
			description: "Token limit for quota warnings (e.g., 500000 or \"max\")"
		},
		sessionLength: {
			type: "number",
			short: "n",
			description: `Session block duration in hours (default: ${DEFAULT_SESSION_DURATION_HOURS})`,
			default: DEFAULT_SESSION_DURATION_HOURS
		}
	},
	toKebab: true,
	async run(ctx) {
		const mergedOptions = mergeConfigWithArgs(ctx, loadConfig(ctx.values.config, ctx.values.debug), ctx.values.debug);
		const useJson = mergedOptions.json || mergedOptions.jq != null;
		if (useJson) logger.level = 0;
		if (ctx.values.sessionLength <= 0) {
			logger.error("Session length must be a positive number");
			process$1.exit(1);
		}
		let blocks = await loadSessionBlockData({
			since: ctx.values.since,
			until: ctx.values.until,
			mode: ctx.values.mode,
			order: ctx.values.order,
			offline: ctx.values.offline,
			sessionDurationHours: ctx.values.sessionLength,
			timezone: ctx.values.timezone,
			locale: ctx.values.locale
		});
		if (blocks.length === 0) {
			if (useJson) log(JSON.stringify({ blocks: [] }));
			else logger.warn("No Claude usage data found.");
			process$1.exit(0);
		}
		let maxTokensFromAll = 0;
		if (ctx.values.tokenLimit === "max" || ctx.values.tokenLimit == null || ctx.values.tokenLimit === "") {
			for (const block of blocks) if (!(block.isGap ?? false) && !block.isActive) {
				const blockTokens = getTotalTokens(block.tokenCounts);
				if (blockTokens > maxTokensFromAll) maxTokensFromAll = blockTokens;
			}
			if (!useJson && maxTokensFromAll > 0) logger.info(`Using max tokens from previous sessions: ${formatNumber(maxTokensFromAll)}`);
		}
		if (ctx.values.recent) blocks = filterRecentBlocks(blocks, DEFAULT_RECENT_DAYS);
		if (ctx.values.active) {
			blocks = blocks.filter((block) => block.isActive);
			if (blocks.length === 0) {
				if (useJson) log(JSON.stringify({
					blocks: [],
					message: "No active block"
				}));
				else logger.info("No active session block found.");
				process$1.exit(0);
			}
		}
		if (useJson) {
			const jsonOutput = { blocks: blocks.map((block) => {
				const burnRate = block.isActive ? calculateBurnRate(block) : null;
				const projection = block.isActive ? projectBlockUsage(block) : null;
				return {
					id: block.id,
					startTime: block.startTime.toISOString(),
					endTime: block.endTime.toISOString(),
					actualEndTime: block.actualEndTime?.toISOString() ?? null,
					isActive: block.isActive,
					isGap: block.isGap ?? false,
					entries: block.entries.length,
					tokenCounts: block.tokenCounts,
					totalTokens: getTotalTokens(block.tokenCounts),
					costUSD: block.costUSD,
					models: block.models,
					burnRate,
					projection,
					tokenLimitStatus: projection != null && ctx.values.tokenLimit != null ? (() => {
						const limit = parseTokenLimit(ctx.values.tokenLimit, maxTokensFromAll);
						return limit != null ? {
							limit,
							projectedUsage: projection.totalTokens,
							percentUsed: projection.totalTokens / limit * 100,
							status: projection.totalTokens > limit ? "exceeds" : projection.totalTokens > limit * BLOCKS_WARNING_THRESHOLD ? "warning" : "ok"
						} : void 0;
					})() : void 0,
					usageLimitResetTime: block.usageLimitResetTime
				};
			}) };
			if (ctx.values.jq != null) {
				const jqResult = await processWithJq(jsonOutput, ctx.values.jq);
				if (isFailure(jqResult)) {
					logger.error(jqResult.error.message);
					process$1.exit(1);
				}
				log(jqResult.value);
			} else log(JSON.stringify(jsonOutput, null, 2));
		} else if (ctx.values.active && blocks.length === 1) {
			const block = blocks[0];
			if (block == null) {
				logger.warn("No active block found.");
				process$1.exit(0);
			}
			const burnRate = calculateBurnRate(block);
			const projection = projectBlockUsage(block);
			logger.box("Current Session Block Status");
			const now = /* @__PURE__ */ new Date();
			const elapsed = Math.round((now.getTime() - block.startTime.getTime()) / (1e3 * 60));
			const remaining = Math.round((block.endTime.getTime() - now.getTime()) / (1e3 * 60));
			log(`Block Started: ${import_picocolors$2.default.cyan(block.startTime.toLocaleString())} (${import_picocolors$2.default.yellow(`${Math.floor(elapsed / 60)}h ${elapsed % 60}m`)} ago)`);
			log(`Time Remaining: ${import_picocolors$2.default.green(`${Math.floor(remaining / 60)}h ${remaining % 60}m`)}\n`);
			log(import_picocolors$2.default.bold("Current Usage:"));
			log(`  Input Tokens:     ${formatNumber(block.tokenCounts.inputTokens)}`);
			log(`  Output Tokens:    ${formatNumber(block.tokenCounts.outputTokens)}`);
			log(`  Total Cost:       ${formatCurrency(block.costUSD)}\n`);
			if (burnRate != null) {
				log(import_picocolors$2.default.bold("Burn Rate:"));
				log(`  Tokens/minute:    ${formatNumber(burnRate.tokensPerMinute)}`);
				log(`  Cost/hour:        ${formatCurrency(burnRate.costPerHour)}\n`);
			}
			if (projection != null) {
				log(import_picocolors$2.default.bold("Projected Usage (if current rate continues):"));
				log(`  Total Tokens:     ${formatNumber(projection.totalTokens)}`);
				log(`  Total Cost:       ${formatCurrency(projection.totalCost)}\n`);
				if (ctx.values.tokenLimit != null) {
					const limit = parseTokenLimit(ctx.values.tokenLimit, maxTokensFromAll);
					if (limit != null && limit > 0) {
						const currentTokens = getTotalTokens(block.tokenCounts);
						const remainingTokens = Math.max(0, limit - currentTokens);
						const percentUsed = projection.totalTokens / limit * 100;
						const status = percentUsed > 100 ? import_picocolors$2.default.red("EXCEEDS LIMIT") : percentUsed > BLOCKS_WARNING_THRESHOLD * 100 ? import_picocolors$2.default.yellow("WARNING") : import_picocolors$2.default.green("OK");
						log(import_picocolors$2.default.bold("Token Limit Status:"));
						log(`  Limit:            ${formatNumber(limit)} tokens`);
						log(`  Current Usage:    ${formatNumber(currentTokens)} (${(currentTokens / limit * 100).toFixed(1)}%)`);
						log(`  Remaining:        ${formatNumber(remainingTokens)} tokens`);
						log(`  Projected Usage:  ${percentUsed.toFixed(1)}% ${status}`);
					}
				}
			}
		} else {
			logger.box("Claude Code Token Usage Report - Session Blocks");
			const actualTokenLimit = parseTokenLimit(ctx.values.tokenLimit, maxTokensFromAll);
			const tableHeaders = [
				"Block Start",
				"Duration/Status",
				"Models",
				"Tokens"
			];
			const tableAligns = [
				"left",
				"left",
				"left",
				"right"
			];
			if (actualTokenLimit != null && actualTokenLimit > 0) {
				tableHeaders.push("%");
				tableAligns.push("right");
			}
			tableHeaders.push("Cost");
			tableAligns.push("right");
			const table = new ResponsiveTable({
				head: tableHeaders,
				style: { head: ["cyan"] },
				colAligns: tableAligns
			});
			const isNarrowTerminal = (process$1.stdout.columns || BLOCKS_DEFAULT_TERMINAL_WIDTH) < BLOCKS_COMPACT_WIDTH_THRESHOLD;
			const useCompactFormat = ctx.values.compact || isNarrowTerminal;
			for (const block of blocks) if (block.isGap ?? false) {
				const gapRow = [
					import_picocolors$2.default.gray(formatBlockTime(block, useCompactFormat, ctx.values.locale)),
					import_picocolors$2.default.gray("(inactive)"),
					import_picocolors$2.default.gray("-"),
					import_picocolors$2.default.gray("-")
				];
				if (actualTokenLimit != null && actualTokenLimit > 0) gapRow.push(import_picocolors$2.default.gray("-"));
				gapRow.push(import_picocolors$2.default.gray("-"));
				table.push(gapRow);
			} else {
				const totalTokens = getTotalTokens(block.tokenCounts);
				const status = block.isActive ? import_picocolors$2.default.green("ACTIVE") : "";
				const row = [
					formatBlockTime(block, useCompactFormat, ctx.values.locale),
					status,
					formatModels(block.models),
					formatNumber(totalTokens)
				];
				if (actualTokenLimit != null && actualTokenLimit > 0) {
					const percentage = totalTokens / actualTokenLimit * 100;
					const percentText = `${percentage.toFixed(1)}%`;
					row.push(percentage > 100 ? import_picocolors$2.default.red(percentText) : percentText);
				}
				row.push(formatCurrency(block.costUSD));
				table.push(row);
				if (block.isActive) {
					if (actualTokenLimit != null && actualTokenLimit > 0) {
						const currentTokens = getTotalTokens(block.tokenCounts);
						const remainingTokens = Math.max(0, actualTokenLimit - currentTokens);
						const remainingText = remainingTokens > 0 ? formatNumber(remainingTokens) : import_picocolors$2.default.red("0");
						const remainingPercent = (actualTokenLimit - currentTokens) / actualTokenLimit * 100;
						const remainingPercentText = remainingPercent > 0 ? `${remainingPercent.toFixed(1)}%` : import_picocolors$2.default.red("0.0%");
						const remainingRow = [
							{
								content: import_picocolors$2.default.gray(`(assuming ${formatNumber(actualTokenLimit)} token limit)`),
								hAlign: "right"
							},
							import_picocolors$2.default.blue("REMAINING"),
							"",
							remainingText,
							remainingPercentText,
							""
						];
						table.push(remainingRow);
					}
					const projection = projectBlockUsage(block);
					if (projection != null) {
						const projectedTokens = formatNumber(projection.totalTokens);
						const projectedText = actualTokenLimit != null && actualTokenLimit > 0 && projection.totalTokens > actualTokenLimit ? import_picocolors$2.default.red(projectedTokens) : projectedTokens;
						const projectedRow = [
							{
								content: import_picocolors$2.default.gray("(assuming current burn rate)"),
								hAlign: "right"
							},
							import_picocolors$2.default.yellow("PROJECTED"),
							"",
							projectedText
						];
						if (actualTokenLimit != null && actualTokenLimit > 0) {
							const percentText = `${(projection.totalTokens / actualTokenLimit * 100).toFixed(1)}%`;
							projectedRow.push(percentText);
						}
						projectedRow.push(formatCurrency(projection.totalCost));
						table.push(projectedRow);
					}
				}
			}
			log(table.toString());
		}
	}
});
function groupByProject(dailyData) {
	const projects = {};
	for (const data of dailyData) {
		const projectName = data.project ?? "unknown";
		if (projects[projectName] == null) projects[projectName] = [];
		projects[projectName].push({
			date: data.date,
			inputTokens: data.inputTokens,
			outputTokens: data.outputTokens,
			cacheCreationTokens: data.cacheCreationTokens,
			cacheReadTokens: data.cacheReadTokens,
			totalTokens: getTotalTokens(data),
			totalCost: data.totalCost,
			modelsUsed: data.modelsUsed,
			modelBreakdowns: data.modelBreakdowns
		});
	}
	return projects;
}
function groupDataByProject(dailyData) {
	const projects = {};
	for (const data of dailyData) {
		const projectName = data.project ?? "unknown";
		if (projects[projectName] == null) projects[projectName] = [];
		projects[projectName].push(data);
	}
	return projects;
}
function parseProjectName(projectName) {
	if (projectName === "unknown" || projectName === "") return "Unknown Project";
	let cleaned = projectName;
	if (cleaned.match(/^[A-Z]:\\Users\\|^\\Users\\/) != null) {
		const segments = cleaned.split("\\");
		const userIndex = segments.findIndex((seg) => seg === "Users");
		if (userIndex !== -1 && userIndex + 3 < segments.length) cleaned = segments.slice(userIndex + 3).join("-");
	}
	if (cleaned.startsWith("-Users-") || cleaned.startsWith("/Users/")) {
		const separator = cleaned.startsWith("-Users-") ? "-" : "/";
		const segments = cleaned.split(separator).filter((s) => s.length > 0);
		const userIndex = segments.findIndex((seg) => seg === "Users");
		if (userIndex !== -1 && userIndex + 3 < segments.length) cleaned = segments.slice(userIndex + 3).join("-");
	}
	if (cleaned === projectName) cleaned = projectName.replace(/^[/\\-]+|[/\\-]+$/g, "");
	if (cleaned.match(/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}/i) != null) {
		const parts = cleaned.split("-");
		if (parts.length >= 5) cleaned = parts.slice(-2).join("-");
	}
	if (cleaned.includes("--")) {
		const parts = cleaned.split("--");
		if (parts.length >= 2 && parts[0] != null) cleaned = parts[0];
	}
	if (cleaned.includes("-") && cleaned.length > 20) {
		const meaningfulSegments = cleaned.split("-").filter((seg) => seg.length > 2 && seg.match(/^(?:dev|development|feat|feature|fix|bug|test|staging|prod|production|main|master|branch)$/i) == null);
		if (meaningfulSegments.length >= 2) {
			const lastSegments = meaningfulSegments.slice(-2);
			if (lastSegments.join("-").length >= 6) cleaned = lastSegments.join("-");
			else if (meaningfulSegments.length >= 3) cleaned = meaningfulSegments.slice(-3).join("-");
		}
	}
	cleaned = cleaned.replace(/^[/\\-]+|[/\\-]+$/g, "");
	return cleaned !== "" ? cleaned : projectName !== "" ? projectName : "Unknown Project";
}
function formatProjectName(projectName, aliases) {
	if (aliases != null && aliases.has(projectName)) return aliases.get(projectName);
	const parsed = parseProjectName(projectName);
	if (aliases != null && aliases.has(parsed)) return aliases.get(parsed);
	return parsed;
}
var import_picocolors$1 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const dailyCommand = define({
	name: "daily",
	description: "Show usage report grouped by date",
	...sharedCommandConfig,
	args: {
		...sharedCommandConfig.args,
		instances: {
			type: "boolean",
			short: "i",
			description: "Show usage breakdown by project/instance",
			default: false
		},
		project: {
			type: "string",
			short: "p",
			description: "Filter to specific project name"
		},
		projectAliases: {
			type: "string",
			description: "Comma-separated project aliases (e.g., 'ccusage=Usage Tracker,myproject=My Project')",
			hidden: true
		}
	},
	async run(ctx) {
		const mergedOptions = mergeConfigWithArgs(ctx, loadConfig(ctx.values.config, ctx.values.debug), ctx.values.debug);
		let projectAliases;
		if (mergedOptions.projectAliases != null && typeof mergedOptions.projectAliases === "string") {
			projectAliases = /* @__PURE__ */ new Map();
			const pairs$1 = mergedOptions.projectAliases.split(",").map((pair$1) => pair$1.trim()).filter((pair$1) => pair$1 !== "");
			for (const pair$1 of pairs$1) {
				const parts = pair$1.split("=").map((s) => s.trim());
				const rawName = parts[0];
				const alias = parts[1];
				if (rawName != null && alias != null && rawName !== "" && alias !== "") projectAliases.set(rawName, alias);
			}
		}
		const useJson = Boolean(mergedOptions.json) || mergedOptions.jq != null;
		if (useJson) logger.level = 0;
		const dailyData = await loadDailyUsageData({
			...mergedOptions,
			groupByProject: mergedOptions.instances
		});
		if (dailyData.length === 0) {
			if (useJson) log(JSON.stringify([]));
			else logger.warn("No Claude usage data found.");
			process$1.exit(0);
		}
		const totals = calculateTotals(dailyData);
		if (mergedOptions.debug && !useJson) printMismatchReport(await detectMismatches(void 0), mergedOptions.debugSamples);
		if (useJson) {
			const jsonOutput = Boolean(mergedOptions.instances) && dailyData.some((d) => d.project != null) ? {
				projects: groupByProject(dailyData),
				totals: createTotalsObject(totals)
			} : {
				daily: dailyData.map((data) => ({
					date: data.date,
					inputTokens: data.inputTokens,
					outputTokens: data.outputTokens,
					cacheCreationTokens: data.cacheCreationTokens,
					cacheReadTokens: data.cacheReadTokens,
					totalTokens: getTotalTokens(data),
					totalCost: data.totalCost,
					modelsUsed: data.modelsUsed,
					modelBreakdowns: data.modelBreakdowns,
					...data.project != null && { project: data.project }
				})),
				totals: createTotalsObject(totals)
			};
			if (mergedOptions.jq != null) {
				const jqResult = await processWithJq(jsonOutput, mergedOptions.jq);
				if (isFailure(jqResult)) {
					logger.error(jqResult.error.message);
					process$1.exit(1);
				}
				log(jqResult.value);
			} else log(JSON.stringify(jsonOutput, null, 2));
		} else {
			logger.box("Claude Code Token Usage Report - Daily");
			const table = createUsageReportTable({
				firstColumnName: "Date",
				dateFormatter: (dateStr) => formatDateCompact(dateStr, mergedOptions.timezone, mergedOptions.locale ?? void 0),
				forceCompact: ctx.values.compact
			});
			if (Boolean(mergedOptions.instances) && dailyData.some((d) => d.project != null)) {
				const projectGroups = groupDataByProject(dailyData);
				let isFirstProject = true;
				for (const [projectName, projectData] of Object.entries(projectGroups)) {
					if (!isFirstProject) table.push([
						"",
						"",
						"",
						"",
						"",
						"",
						"",
						""
					]);
					table.push([
						import_picocolors$1.default.cyan(`Project: ${formatProjectName(projectName, projectAliases)}`),
						"",
						"",
						"",
						"",
						"",
						"",
						""
					]);
					for (const data of projectData) {
						const row = formatUsageDataRow(data.date, {
							inputTokens: data.inputTokens,
							outputTokens: data.outputTokens,
							cacheCreationTokens: data.cacheCreationTokens,
							cacheReadTokens: data.cacheReadTokens,
							totalCost: data.totalCost,
							modelsUsed: data.modelsUsed
						});
						table.push(row);
						if (mergedOptions.breakdown) pushBreakdownRows(table, data.modelBreakdowns);
					}
					isFirstProject = false;
				}
			} else for (const data of dailyData) {
				const row = formatUsageDataRow(data.date, {
					inputTokens: data.inputTokens,
					outputTokens: data.outputTokens,
					cacheCreationTokens: data.cacheCreationTokens,
					cacheReadTokens: data.cacheReadTokens,
					totalCost: data.totalCost,
					modelsUsed: data.modelsUsed
				});
				table.push(row);
				if (mergedOptions.breakdown) pushBreakdownRows(table, data.modelBreakdowns);
			}
			addEmptySeparatorRow(table, 8);
			const totalsRow = formatTotalsRow({
				inputTokens: totals.inputTokens,
				outputTokens: totals.outputTokens,
				cacheCreationTokens: totals.cacheCreationTokens,
				cacheReadTokens: totals.cacheReadTokens,
				totalCost: totals.totalCost
			});
			table.push(totalsRow);
			log(table.toString());
			if (table.isCompactMode()) {
				logger.info("\nRunning in Compact Mode");
				logger.info("Expand terminal width to see cache metrics and total tokens");
			}
		}
	}
});
const monthlyCommand = define({
	name: "monthly",
	description: "Show usage report grouped by month",
	...sharedCommandConfig,
	async run(ctx) {
		const mergedOptions = mergeConfigWithArgs(ctx, loadConfig(ctx.values.config, ctx.values.debug), ctx.values.debug);
		const useJson = Boolean(mergedOptions.json) || mergedOptions.jq != null;
		if (useJson) logger.level = 0;
		const monthlyData = await loadMonthlyUsageData(mergedOptions);
		if (monthlyData.length === 0) {
			if (useJson) log(JSON.stringify({
				monthly: [],
				totals: {
					inputTokens: 0,
					outputTokens: 0,
					cacheCreationTokens: 0,
					cacheReadTokens: 0,
					totalTokens: 0,
					totalCost: 0
				}
			}, null, 2));
			else logger.warn("No Claude usage data found.");
			process$1.exit(0);
		}
		const totals = calculateTotals(monthlyData);
		if (mergedOptions.debug && !useJson) printMismatchReport(await detectMismatches(void 0), mergedOptions.debugSamples);
		if (useJson) {
			const jsonOutput = {
				monthly: monthlyData.map((data) => ({
					month: data.month,
					inputTokens: data.inputTokens,
					outputTokens: data.outputTokens,
					cacheCreationTokens: data.cacheCreationTokens,
					cacheReadTokens: data.cacheReadTokens,
					totalTokens: getTotalTokens(data),
					totalCost: data.totalCost,
					modelsUsed: data.modelsUsed,
					modelBreakdowns: data.modelBreakdowns
				})),
				totals: createTotalsObject(totals)
			};
			if (mergedOptions.jq != null) {
				const jqResult = await processWithJq(jsonOutput, mergedOptions.jq);
				if (isFailure(jqResult)) {
					logger.error(jqResult.error.message);
					process$1.exit(1);
				}
				log(jqResult.value);
			} else log(JSON.stringify(jsonOutput, null, 2));
		} else {
			logger.box("Claude Code Token Usage Report - Monthly");
			const table = createUsageReportTable({
				firstColumnName: "Month",
				dateFormatter: (dateStr) => formatDateCompact(dateStr, mergedOptions.timezone, mergedOptions.locale ?? DEFAULT_LOCALE),
				forceCompact: ctx.values.compact
			});
			for (const data of monthlyData) {
				const row = formatUsageDataRow(data.month, {
					inputTokens: data.inputTokens,
					outputTokens: data.outputTokens,
					cacheCreationTokens: data.cacheCreationTokens,
					cacheReadTokens: data.cacheReadTokens,
					totalCost: data.totalCost,
					modelsUsed: data.modelsUsed
				});
				table.push(row);
				if (mergedOptions.breakdown) pushBreakdownRows(table, data.modelBreakdowns);
			}
			addEmptySeparatorRow(table, 8);
			const totalsRow = formatTotalsRow({
				inputTokens: totals.inputTokens,
				outputTokens: totals.outputTokens,
				cacheCreationTokens: totals.cacheCreationTokens,
				cacheReadTokens: totals.cacheReadTokens,
				totalCost: totals.totalCost
			});
			table.push(totalsRow);
			log(table.toString());
			if (table.isCompactMode()) {
				logger.info("\nRunning in Compact Mode");
				logger.info("Expand terminal width to see cache metrics and total tokens");
			}
		}
	}
});
async function handleSessionIdLookup(ctx, useJson) {
	const sessionUsage = await loadSessionUsageById(ctx.values.id, {
		mode: ctx.values.mode,
		offline: ctx.values.offline
	});
	if (sessionUsage == null) {
		if (useJson) log(JSON.stringify(null));
		else logger.warn(`No session found with ID: ${ctx.values.id}`);
		process$1.exit(0);
	}
	if (useJson) {
		const jsonOutput = {
			sessionId: ctx.values.id,
			totalCost: sessionUsage.totalCost,
			totalTokens: calculateSessionTotalTokens(sessionUsage.entries),
			entries: sessionUsage.entries.map((entry) => ({
				timestamp: entry.timestamp,
				inputTokens: entry.message.usage.input_tokens,
				outputTokens: entry.message.usage.output_tokens,
				cacheCreationTokens: entry.message.usage.cache_creation_input_tokens ?? 0,
				cacheReadTokens: entry.message.usage.cache_read_input_tokens ?? 0,
				model: entry.message.model ?? "unknown",
				costUSD: entry.costUSD ?? 0
			}))
		};
		if (ctx.values.jq != null) {
			const jqResult = await processWithJq(jsonOutput, ctx.values.jq);
			if (isFailure(jqResult)) {
				logger.error(jqResult.error.message);
				process$1.exit(1);
			}
			log(jqResult.value);
		} else log(JSON.stringify(jsonOutput, null, 2));
	} else {
		logger.box(`Claude Code Session Usage - ${ctx.values.id}`);
		const totalTokens = calculateSessionTotalTokens(sessionUsage.entries);
		log(`Total Cost: ${formatCurrency(sessionUsage.totalCost)}`);
		log(`Total Tokens: ${formatNumber(totalTokens)}`);
		log(`Total Entries: ${sessionUsage.entries.length}`);
		log("");
		if (sessionUsage.entries.length > 0) {
			const table = new ResponsiveTable({
				head: [
					"Timestamp",
					"Model",
					"Input",
					"Output",
					"Cache Create",
					"Cache Read",
					"Cost (USD)"
				],
				style: { head: ["cyan"] },
				colAligns: [
					"left",
					"left",
					"right",
					"right",
					"right",
					"right",
					"right"
				]
			});
			for (const entry of sessionUsage.entries) table.push([
				formatDateCompact(entry.timestamp, ctx.values.timezone, ctx.values.locale),
				entry.message.model ?? "unknown",
				formatNumber(entry.message.usage.input_tokens),
				formatNumber(entry.message.usage.output_tokens),
				formatNumber(entry.message.usage.cache_creation_input_tokens ?? 0),
				formatNumber(entry.message.usage.cache_read_input_tokens ?? 0),
				formatCurrency(entry.costUSD ?? 0)
			]);
			log(table.toString());
		}
	}
}
function calculateSessionTotalTokens(entries) {
	return entries.reduce((sum, entry) => {
		const usage = entry.message.usage;
		return sum + usage.input_tokens + usage.output_tokens + (usage.cache_creation_input_tokens ?? 0) + (usage.cache_read_input_tokens ?? 0);
	}, 0);
}
const { order: _, ...sharedArgs$1 } = sharedCommandConfig.args;
const sessionCommand = define({
	name: "session",
	description: "Show usage report grouped by conversation session",
	...sharedCommandConfig,
	args: {
		...sharedArgs$1,
		id: {
			type: "string",
			short: "i",
			description: "Load usage data for a specific session ID"
		}
	},
	toKebab: true,
	async run(ctx) {
		const mergedOptions = mergeConfigWithArgs(ctx, loadConfig(ctx.values.config, ctx.values.debug), ctx.values.debug);
		const useJson = mergedOptions.json || mergedOptions.jq != null;
		if (useJson) logger.level = 0;
		if (mergedOptions.id != null) return handleSessionIdLookup({ values: {
			id: mergedOptions.id,
			mode: mergedOptions.mode,
			offline: mergedOptions.offline,
			jq: mergedOptions.jq,
			timezone: mergedOptions.timezone,
			locale: mergedOptions.locale ?? DEFAULT_LOCALE
		} }, useJson);
		const sessionData = await loadSessionData({
			since: ctx.values.since,
			until: ctx.values.until,
			mode: ctx.values.mode,
			offline: ctx.values.offline,
			timezone: ctx.values.timezone,
			locale: ctx.values.locale
		});
		if (sessionData.length === 0) {
			if (useJson) log(JSON.stringify([]));
			else logger.warn("No Claude usage data found.");
			process$1.exit(0);
		}
		const totals = calculateTotals(sessionData);
		if (ctx.values.debug && !useJson) printMismatchReport(await detectMismatches(void 0), ctx.values.debugSamples);
		if (useJson) {
			const jsonOutput = {
				sessions: sessionData.map((data) => ({
					sessionId: data.sessionId,
					inputTokens: data.inputTokens,
					outputTokens: data.outputTokens,
					cacheCreationTokens: data.cacheCreationTokens,
					cacheReadTokens: data.cacheReadTokens,
					totalTokens: getTotalTokens(data),
					totalCost: data.totalCost,
					lastActivity: data.lastActivity,
					modelsUsed: data.modelsUsed,
					modelBreakdowns: data.modelBreakdowns,
					projectPath: data.projectPath
				})),
				totals: createTotalsObject(totals)
			};
			if (ctx.values.jq != null) {
				const jqResult = await processWithJq(jsonOutput, ctx.values.jq);
				if (isFailure(jqResult)) {
					logger.error(jqResult.error.message);
					process$1.exit(1);
				}
				log(jqResult.value);
			} else log(JSON.stringify(jsonOutput, null, 2));
		} else {
			logger.box("Claude Code Token Usage Report - By Session");
			const table = createUsageReportTable({
				firstColumnName: "Session",
				includeLastActivity: true,
				dateFormatter: (dateStr) => formatDateCompact(dateStr, ctx.values.timezone, ctx.values.locale),
				forceCompact: ctx.values.compact
			});
			let maxSessionLength = 0;
			for (const data of sessionData) {
				const sessionDisplay = data.sessionId.split("-").slice(-2).join("-");
				maxSessionLength = Math.max(maxSessionLength, sessionDisplay.length);
				const row = formatUsageDataRow(sessionDisplay, {
					inputTokens: data.inputTokens,
					outputTokens: data.outputTokens,
					cacheCreationTokens: data.cacheCreationTokens,
					cacheReadTokens: data.cacheReadTokens,
					totalCost: data.totalCost,
					modelsUsed: data.modelsUsed
				}, data.lastActivity);
				table.push(row);
				if (ctx.values.breakdown) pushBreakdownRows(table, data.modelBreakdowns, 1, 1);
			}
			addEmptySeparatorRow(table, 9);
			const totalsRow = formatTotalsRow({
				inputTokens: totals.inputTokens,
				outputTokens: totals.outputTokens,
				cacheCreationTokens: totals.cacheCreationTokens,
				cacheReadTokens: totals.cacheReadTokens,
				totalCost: totals.totalCost
			}, true);
			table.push(totalsRow);
			log(table.toString());
			if (table.isCompactMode()) {
				logger.info("\nRunning in Compact Mode");
				logger.info("Expand terminal width to see cache metrics and total tokens");
			}
		}
	}
});
function filterInPlace(array, predicate) {
	let outputIndex = 0;
	for (const cur of array) {
		if (!predicate(cur)) continue;
		array[outputIndex] = cur;
		outputIndex += 1;
	}
	array.splice(outputIndex);
	return array;
}
function deepMerge(record, other, options) {
	return deepMergeInternal(record, other, /* @__PURE__ */ new Set(), options);
}
function deepMergeInternal(record, other, seen, options) {
	const result = {};
	const keys = new Set([...getKeys(record), ...getKeys(other)]);
	for (const key of keys) {
		if (key === "__proto__") continue;
		const a$1 = record[key];
		if (!Object.hasOwn(other, key)) {
			result[key] = a$1;
			continue;
		}
		const b$1 = other[key];
		if (isNonNullObject(a$1) && isNonNullObject(b$1) && !seen.has(a$1) && !seen.has(b$1)) {
			seen.add(a$1);
			seen.add(b$1);
			result[key] = mergeObjects(a$1, b$1, seen, options);
			continue;
		}
		result[key] = b$1;
	}
	return result;
}
function mergeObjects(left, right, seen, options = {
	arrays: "merge",
	sets: "merge",
	maps: "merge"
}) {
	if (isMergeable(left) && isMergeable(right)) return deepMergeInternal(left, right, seen, options);
	if (isIterable(left) && isIterable(right)) {
		if (Array.isArray(left) && Array.isArray(right)) {
			if (options.arrays === "merge") return left.concat(right);
			return right;
		}
		if (left instanceof Map && right instanceof Map) {
			if (options.maps === "merge") return new Map([...left, ...right]);
			return right;
		}
		if (left instanceof Set && right instanceof Set) {
			if (options.sets === "merge") return new Set([...left, ...right]);
			return right;
		}
	}
	return right;
}
function isMergeable(value$1) {
	return Object.getPrototypeOf(value$1) === Object.prototype;
}
function isIterable(value$1) {
	return typeof value$1[Symbol.iterator] === "function";
}
function isNonNullObject(value$1) {
	return value$1 !== null && typeof value$1 === "object";
}
function getKeys(record) {
	const result = Object.getOwnPropertySymbols(record);
	filterInPlace(result, (key) => Object.prototype.propertyIsEnumerable.call(record, key));
	result.push(...Object.keys(record));
	return result;
}
function isLeap(yearNumber) {
	return yearNumber % 4 === 0 && yearNumber % 100 !== 0 || yearNumber % 400 === 0;
}
function success(body) {
	return {
		ok: true,
		body
	};
}
function failure() {
	return { ok: false };
}
function unflat(keys, values = { __proto__: null }) {
	return keys.reduceRight((acc, key) => ({ [key]: acc }), values);
}
function or(parsers) {
	return (scanner) => {
		for (const parse$2 of parsers) {
			const result = parse$2(scanner);
			if (result.ok) return result;
		}
		return failure();
	};
}
function join$1(parser, separator) {
	const Separator = character(separator);
	return (scanner) => {
		const out = [];
		const first = parser(scanner);
		if (!first.ok) return success(out);
		out.push(first.body);
		while (!scanner.eof()) {
			if (!Separator(scanner).ok) break;
			const result = parser(scanner);
			if (!result.ok) throw new SyntaxError(`Invalid token after "${separator}"`);
			out.push(result.body);
		}
		return success(out);
	};
}
function join1(parser, separator) {
	const Separator = character(separator);
	return (scanner) => {
		const first = parser(scanner);
		if (!first.ok) return failure();
		const out = [first.body];
		while (!scanner.eof()) {
			if (!Separator(scanner).ok) break;
			const result = parser(scanner);
			if (!result.ok) throw new SyntaxError(`Invalid token after "${separator}"`);
			out.push(result.body);
		}
		return success(out);
	};
}
function kv(keyParser, separator, valueParser) {
	const Separator = character(separator);
	return (scanner) => {
		const position = scanner.position;
		const key = keyParser(scanner);
		if (!key.ok) return failure();
		if (!Separator(scanner).ok) throw new SyntaxError(`key/value pair doesn't have "${separator}"`);
		const value$1 = valueParser(scanner);
		if (!value$1.ok) {
			const lineEndIndex = scanner.source.indexOf("\n", scanner.position);
			const endPosition = lineEndIndex > 0 ? lineEndIndex : scanner.source.length;
			const line = scanner.source.slice(position, endPosition);
			throw new SyntaxError(`Cannot parse value on line '${line}'`);
		}
		return success(unflat(key.body, value$1.body));
	};
}
function surround(left, parser, right) {
	const Left = character(left);
	const Right = character(right);
	return (scanner) => {
		if (!Left(scanner).ok) return failure();
		const result = parser(scanner);
		if (!result.ok) throw new SyntaxError(`Invalid token after "${left}"`);
		if (!Right(scanner).ok) throw new SyntaxError(`Not closed by "${right}" after started with "${left}"`);
		return success(result.body);
	};
}
function character(str$1) {
	return (scanner) => {
		scanner.skipWhitespaces();
		if (!scanner.startsWith(str$1)) return failure();
		scanner.next(str$1.length);
		scanner.skipWhitespaces();
		return success(void 0);
	};
}
const BARE_KEY_REGEXP = /[A-Za-z0-9_-]+/y;
function bareKey(scanner) {
	scanner.skipWhitespaces();
	const key = scanner.match(BARE_KEY_REGEXP)?.[0];
	if (!key) return failure();
	scanner.next(key.length);
	return success(key);
}
function escapeSequence(scanner) {
	if (scanner.char() !== "\\") return failure();
	scanner.next();
	switch (scanner.char()) {
		case "b":
			scanner.next();
			return success("\b");
		case "t":
			scanner.next();
			return success("	");
		case "n":
			scanner.next();
			return success("\n");
		case "f":
			scanner.next();
			return success("\f");
		case "r":
			scanner.next();
			return success("\r");
		case "u":
		case "U": {
			const codePointLen = scanner.char() === "u" ? 4 : 6;
			const codePoint = parseInt("0x" + scanner.slice(1, 1 + codePointLen), 16);
			const str$1 = String.fromCodePoint(codePoint);
			scanner.next(codePointLen + 1);
			return success(str$1);
		}
		case "\"":
			scanner.next();
			return success("\"");
		case "\\":
			scanner.next();
			return success("\\");
		default: throw new SyntaxError(`Invalid escape sequence: \\${scanner.char()}`);
	}
}
function basicString(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "\"") return failure();
	scanner.next();
	const acc = [];
	while (scanner.char() !== "\"" && !scanner.eof()) {
		if (scanner.char() === "\n") throw new SyntaxError("Single-line string cannot contain EOL");
		const escapedChar = escapeSequence(scanner);
		if (escapedChar.ok) acc.push(escapedChar.body);
		else {
			acc.push(scanner.char());
			scanner.next();
		}
	}
	if (scanner.eof()) throw new SyntaxError(`Single-line string is not closed:\n${acc.join("")}`);
	scanner.next();
	return success(acc.join(""));
}
function literalString(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "'") return failure();
	scanner.next();
	const acc = [];
	while (scanner.char() !== "'" && !scanner.eof()) {
		if (scanner.char() === "\n") throw new SyntaxError("Single-line string cannot contain EOL");
		acc.push(scanner.char());
		scanner.next();
	}
	if (scanner.eof()) throw new SyntaxError(`Single-line string is not closed:\n${acc.join("")}`);
	scanner.next();
	return success(acc.join(""));
}
function multilineBasicString(scanner) {
	scanner.skipWhitespaces();
	if (!scanner.startsWith("\"\"\"")) return failure();
	scanner.next(3);
	if (scanner.char() === "\n") scanner.next();
	else if (scanner.startsWith("\r\n")) scanner.next(2);
	const acc = [];
	while (!scanner.startsWith("\"\"\"") && !scanner.eof()) {
		if (scanner.startsWith("\\\n")) {
			scanner.next();
			scanner.nextUntilChar({ skipComments: false });
			continue;
		} else if (scanner.startsWith("\\\r\n")) {
			scanner.next();
			scanner.nextUntilChar({ skipComments: false });
			continue;
		}
		const escapedChar = escapeSequence(scanner);
		if (escapedChar.ok) acc.push(escapedChar.body);
		else {
			acc.push(scanner.char());
			scanner.next();
		}
	}
	if (scanner.eof()) throw new SyntaxError(`Multi-line string is not closed:\n${acc.join("")}`);
	if (scanner.char(3) === "\"") {
		acc.push("\"");
		scanner.next();
	}
	scanner.next(3);
	return success(acc.join(""));
}
function multilineLiteralString(scanner) {
	scanner.skipWhitespaces();
	if (!scanner.startsWith("'''")) return failure();
	scanner.next(3);
	if (scanner.char() === "\n") scanner.next();
	else if (scanner.startsWith("\r\n")) scanner.next(2);
	const acc = [];
	while (!scanner.startsWith("'''") && !scanner.eof()) {
		acc.push(scanner.char());
		scanner.next();
	}
	if (scanner.eof()) throw new SyntaxError(`Multi-line string is not closed:\n${acc.join("")}`);
	if (scanner.char(3) === "'") {
		acc.push("'");
		scanner.next();
	}
	scanner.next(3);
	return success(acc.join(""));
}
const BOOLEAN_REGEXP = /(?:true|false)\b/y;
function boolean(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(BOOLEAN_REGEXP);
	if (!match) return failure();
	const string$1 = match[0];
	scanner.next(string$1.length);
	return success(string$1 === "true");
}
const INFINITY_MAP = new Map([
	["inf", Infinity],
	["+inf", Infinity],
	["-inf", -Infinity]
]);
const INFINITY_REGEXP = /[+-]?inf\b/y;
function infinity(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(INFINITY_REGEXP);
	if (!match) return failure();
	const string$1 = match[0];
	scanner.next(string$1.length);
	return success(INFINITY_MAP.get(string$1));
}
const NAN_REGEXP = /[+-]?nan\b/y;
function nan(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(NAN_REGEXP);
	if (!match) return failure();
	const string$1 = match[0];
	scanner.next(string$1.length);
	return success(NaN);
}
const dottedKey = join1(or([
	bareKey,
	basicString,
	literalString
]), ".");
const BINARY_REGEXP = /0b[01]+(?:_[01]+)*\b/y;
function binary$1(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(BINARY_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number$1 = parseInt(value$1, 2);
	return isNaN(number$1) ? failure() : success(number$1);
}
const OCTAL_REGEXP = /0o[0-7]+(?:_[0-7]+)*\b/y;
function octal(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(OCTAL_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number$1 = parseInt(value$1, 8);
	return isNaN(number$1) ? failure() : success(number$1);
}
const HEX_REGEXP = /0x[0-9a-f]+(?:_[0-9a-f]+)*\b/iy;
function hex(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(HEX_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number$1 = parseInt(value$1, 16);
	return isNaN(number$1) ? failure() : success(number$1);
}
const INTEGER_REGEXP = /[+-]?(?:0|[1-9][0-9]*(?:_[0-9]+)*)\b/y;
function integer(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(INTEGER_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.replaceAll("_", "");
	return success(parseInt(value$1, 10));
}
const FLOAT_REGEXP = /[+-]?(?:0|[1-9][0-9]*(?:_[0-9]+)*)(?:\.[0-9]+(?:_[0-9]+)*)?(?:e[+-]?[0-9]+(?:_[0-9]+)*)?\b/iy;
function float$1(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(FLOAT_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.replaceAll("_", "");
	const float$2 = parseFloat(value$1);
	if (isNaN(float$2)) return failure();
	return success(float$2);
}
const DATE_TIME_REGEXP = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})(?:[ 0-9TZ.:+-]+)?\b/y;
function dateTime(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(DATE_TIME_REGEXP);
	if (!match) return failure();
	const string$1 = match[0];
	scanner.next(string$1.length);
	const groups = match.groups;
	if (groups.month == "02") {
		const days = parseInt(groups.day);
		if (days > 29) throw new SyntaxError(`Invalid date string "${match}"`);
		const year = parseInt(groups.year);
		if (days > 28 && !isLeap(year)) throw new SyntaxError(`Invalid date string "${match}"`);
	}
	const date = new Date(string$1.trim());
	if (isNaN(date.getTime())) throw new SyntaxError(`Invalid date string "${match}"`);
	return success(date);
}
const LOCAL_TIME_REGEXP = /(\d{2}):(\d{2}):(\d{2})(?:\.[0-9]+)?\b/y;
function localTime(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(LOCAL_TIME_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	return success(match);
}
function arrayValue(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "[") return failure();
	scanner.next();
	const array = [];
	while (!scanner.eof()) {
		scanner.nextUntilChar();
		const result = value(scanner);
		if (!result.ok) break;
		array.push(result.body);
		scanner.skipWhitespaces();
		if (scanner.char() !== ",") break;
		scanner.next();
	}
	scanner.nextUntilChar();
	if (scanner.char() !== "]") throw new SyntaxError("Array is not closed");
	scanner.next();
	return success(array);
}
function inlineTable(scanner) {
	scanner.nextUntilChar();
	if (scanner.char(1) === "}") {
		scanner.next(2);
		return success({ __proto__: null });
	}
	const pairs$1 = surround("{", join$1(pair, ","), "}")(scanner);
	if (!pairs$1.ok) return failure();
	let table = { __proto__: null };
	for (const pair$1 of pairs$1.body) table = deepMerge(table, pair$1);
	return success(table);
}
const value = or([
	multilineBasicString,
	multilineLiteralString,
	basicString,
	literalString,
	boolean,
	infinity,
	nan,
	dateTime,
	localTime,
	binary$1,
	octal,
	hex,
	float$1,
	integer,
	arrayValue,
	inlineTable
]);
const pair = kv(dottedKey, "=", value);
surround("[", dottedKey, "]");
surround("[[", dottedKey, "]]");
const BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
	if (data === null) return false;
	let code;
	let bitlen = 0;
	const max = data.length;
	const map$2 = BASE64_MAP;
	for (let idx = 0; idx < max; idx++) {
		code = map$2.indexOf(data.charAt(idx));
		if (code > 64) continue;
		if (code < 0) return false;
		bitlen += 6;
	}
	return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
	const input = data.replace(/[\r\n=]/g, "");
	const max = input.length;
	const map$2 = BASE64_MAP;
	const result = [];
	let bits = 0;
	for (let idx = 0; idx < max; idx++) {
		if (idx % 4 === 0 && idx) {
			result.push(bits >> 16 & 255);
			result.push(bits >> 8 & 255);
			result.push(bits & 255);
		}
		bits = bits << 6 | map$2.indexOf(input.charAt(idx));
	}
	const tailbits = max % 4 * 6;
	if (tailbits === 0) {
		result.push(bits >> 16 & 255);
		result.push(bits >> 8 & 255);
		result.push(bits & 255);
	} else if (tailbits === 18) {
		result.push(bits >> 10 & 255);
		result.push(bits >> 2 & 255);
	} else if (tailbits === 12) result.push(bits >> 4 & 255);
	return new Uint8Array(result);
}
function representYamlBinary(object) {
	const max = object.length;
	const map$2 = BASE64_MAP;
	let result = "";
	let bits = 0;
	for (let idx = 0; idx < max; idx++) {
		if (idx % 3 === 0 && idx) {
			result += map$2[bits >> 18 & 63];
			result += map$2[bits >> 12 & 63];
			result += map$2[bits >> 6 & 63];
			result += map$2[bits & 63];
		}
		bits = (bits << 8) + object[idx];
	}
	const tail = max % 3;
	if (tail === 0) {
		result += map$2[bits >> 18 & 63];
		result += map$2[bits >> 12 & 63];
		result += map$2[bits >> 6 & 63];
		result += map$2[bits & 63];
	} else if (tail === 2) {
		result += map$2[bits >> 10 & 63];
		result += map$2[bits >> 4 & 63];
		result += map$2[bits << 2 & 63];
		result += map$2[64];
	} else if (tail === 1) {
		result += map$2[bits >> 2 & 63];
		result += map$2[bits << 4 & 63];
		result += map$2[64];
		result += map$2[64];
	}
	return result;
}
function isBinary(obj) {
	return obj instanceof Uint8Array;
}
const binary = {
	tag: "tag:yaml.org,2002:binary",
	construct: constructYamlBinary,
	kind: "scalar",
	predicate: isBinary,
	represent: representYamlBinary,
	resolve: resolveYamlBinary
};
const YAML_TRUE_BOOLEANS = [
	"true",
	"True",
	"TRUE"
];
const YAML_FALSE_BOOLEANS = [
	"false",
	"False",
	"FALSE"
];
const YAML_BOOLEANS = [...YAML_TRUE_BOOLEANS, ...YAML_FALSE_BOOLEANS];
const bool = {
	tag: "tag:yaml.org,2002:bool",
	kind: "scalar",
	defaultStyle: "lowercase",
	predicate: (value$1) => typeof value$1 === "boolean" || value$1 instanceof Boolean,
	construct: (data) => YAML_TRUE_BOOLEANS.includes(data),
	resolve: (data) => YAML_BOOLEANS.includes(data),
	represent: {
		lowercase: (object) => {
			return (object instanceof Boolean ? object.valueOf() : object) ? "true" : "false";
		},
		uppercase: (object) => {
			return (object instanceof Boolean ? object.valueOf() : object) ? "TRUE" : "FALSE";
		},
		camelcase: (object) => {
			return (object instanceof Boolean ? object.valueOf() : object) ? "True" : "False";
		}
	}
};
function isNegativeZero(i) {
	return i === 0 && Number.NEGATIVE_INFINITY === 1 / i;
}
function isPlainObject(object) {
	return Object.prototype.toString.call(object) === "[object Object]";
}
const YAML_FLOAT_PATTERN = /* @__PURE__ */ new RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
function resolveYamlFloat(data) {
	if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") return false;
	return true;
}
function constructYamlFloat(data) {
	let value$1 = data.replace(/_/g, "").toLowerCase();
	const sign = value$1[0] === "-" ? -1 : 1;
	if (value$1[0] && "+-".includes(value$1[0])) value$1 = value$1.slice(1);
	if (value$1 === ".inf") return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
	if (value$1 === ".nan") return NaN;
	return sign * parseFloat(value$1);
}
const SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
	const value$1 = object instanceof Number ? object.valueOf() : object;
	if (isNaN(value$1)) switch (style) {
		case "lowercase": return ".nan";
		case "uppercase": return ".NAN";
		case "camelcase": return ".NaN";
	}
	else if (Number.POSITIVE_INFINITY === value$1) switch (style) {
		case "lowercase": return ".inf";
		case "uppercase": return ".INF";
		case "camelcase": return ".Inf";
	}
	else if (Number.NEGATIVE_INFINITY === value$1) switch (style) {
		case "lowercase": return "-.inf";
		case "uppercase": return "-.INF";
		case "camelcase": return "-.Inf";
	}
	else if (isNegativeZero(value$1)) return "-0.0";
	const res = value$1.toString(10);
	return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
	if (object instanceof Number) object = object.valueOf();
	return typeof object === "number" && (object % 1 !== 0 || isNegativeZero(object));
}
const float = {
	tag: "tag:yaml.org,2002:float",
	construct: constructYamlFloat,
	defaultStyle: "lowercase",
	kind: "scalar",
	predicate: isFloat,
	represent: representYamlFloat,
	resolve: resolveYamlFloat
};
function isCharCodeInRange(c, lower, upper) {
	return lower <= c && c <= upper;
}
function isHexCode(c) {
	return isCharCodeInRange(c, 48, 57) || isCharCodeInRange(c, 65, 70) || isCharCodeInRange(c, 97, 102);
}
function isOctCode(c) {
	return isCharCodeInRange(c, 48, 55);
}
function isDecCode(c) {
	return isCharCodeInRange(c, 48, 57);
}
function resolveYamlInteger(data) {
	const max = data.length;
	let index = 0;
	let hasDigits = false;
	if (!max) return false;
	let ch = data[index];
	if (ch === "-" || ch === "+") ch = data[++index];
	if (ch === "0") {
		if (index + 1 === max) return true;
		ch = data[++index];
		if (ch === "b") {
			index++;
			for (; index < max; index++) {
				ch = data[index];
				if (ch === "_") continue;
				if (ch !== "0" && ch !== "1") return false;
				hasDigits = true;
			}
			return hasDigits && ch !== "_";
		}
		if (ch === "x") {
			index++;
			for (; index < max; index++) {
				ch = data[index];
				if (ch === "_") continue;
				if (!isHexCode(data.charCodeAt(index))) return false;
				hasDigits = true;
			}
			return hasDigits && ch !== "_";
		}
		for (; index < max; index++) {
			ch = data[index];
			if (ch === "_") continue;
			if (!isOctCode(data.charCodeAt(index))) return false;
			hasDigits = true;
		}
		return hasDigits && ch !== "_";
	}
	if (ch === "_") return false;
	for (; index < max; index++) {
		ch = data[index];
		if (ch === "_") continue;
		if (!isDecCode(data.charCodeAt(index))) return false;
		hasDigits = true;
	}
	if (!hasDigits || ch === "_") return false;
	return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}
function constructYamlInteger(data) {
	let value$1 = data;
	if (value$1.includes("_")) value$1 = value$1.replace(/_/g, "");
	let sign = 1;
	let ch = value$1[0];
	if (ch === "-" || ch === "+") {
		if (ch === "-") sign = -1;
		value$1 = value$1.slice(1);
		ch = value$1[0];
	}
	if (value$1 === "0") return 0;
	if (ch === "0") {
		if (value$1[1] === "b") return sign * parseInt(value$1.slice(2), 2);
		if (value$1[1] === "x") return sign * parseInt(value$1, 16);
		return sign * parseInt(value$1, 8);
	}
	return sign * parseInt(value$1, 10);
}
function isInteger(object) {
	if (object instanceof Number) object = object.valueOf();
	return typeof object === "number" && object % 1 === 0 && !isNegativeZero(object);
}
const int = {
	tag: "tag:yaml.org,2002:int",
	construct: constructYamlInteger,
	defaultStyle: "decimal",
	kind: "scalar",
	predicate: isInteger,
	represent: {
		binary(object) {
			const value$1 = object instanceof Number ? object.valueOf() : object;
			return value$1 >= 0 ? `0b${value$1.toString(2)}` : `-0b${value$1.toString(2).slice(1)}`;
		},
		octal(object) {
			const value$1 = object instanceof Number ? object.valueOf() : object;
			return value$1 >= 0 ? `0${value$1.toString(8)}` : `-0${value$1.toString(8).slice(1)}`;
		},
		decimal(object) {
			return (object instanceof Number ? object.valueOf() : object).toString(10);
		},
		hexadecimal(object) {
			const value$1 = object instanceof Number ? object.valueOf() : object;
			return value$1 >= 0 ? `0x${value$1.toString(16).toUpperCase()}` : `-0x${value$1.toString(16).toUpperCase().slice(1)}`;
		}
	},
	resolve: resolveYamlInteger
};
const map = {
	tag: "tag:yaml.org,2002:map",
	resolve() {
		return true;
	},
	construct(data) {
		return data !== null ? data : {};
	},
	kind: "mapping"
};
const merge = {
	tag: "tag:yaml.org,2002:merge",
	kind: "scalar",
	resolve: (data) => data === "<<" || data === null,
	construct: (data) => data
};
const nil = {
	tag: "tag:yaml.org,2002:null",
	kind: "scalar",
	defaultStyle: "lowercase",
	predicate: (object) => object === null,
	construct: () => null,
	resolve: (data) => {
		return data === "~" || data === "null" || data === "Null" || data === "NULL";
	},
	represent: {
		lowercase: () => "null",
		uppercase: () => "NULL",
		camelcase: () => "Null"
	}
};
function resolveYamlOmap(data) {
	const objectKeys = /* @__PURE__ */ new Set();
	for (const object of data) {
		if (!isPlainObject(object)) return false;
		const keys = Object.keys(object);
		if (keys.length !== 1) return false;
		for (const key of keys) {
			if (objectKeys.has(key)) return false;
			objectKeys.add(key);
		}
	}
	return true;
}
const omap = {
	tag: "tag:yaml.org,2002:omap",
	kind: "sequence",
	resolve: resolveYamlOmap,
	construct(data) {
		return data;
	}
};
function resolveYamlPairs(data) {
	if (data === null) return true;
	return data.every((it) => isPlainObject(it) && Object.keys(it).length === 1);
}
const pairs = {
	tag: "tag:yaml.org,2002:pairs",
	construct(data) {
		return data?.flatMap(Object.entries) ?? [];
	},
	kind: "sequence",
	resolve: resolveYamlPairs
};
const REGEXP = /^\/(?<regexp>[\s\S]+)\/(?<modifiers>[gismuy]*)$/;
const regexp = {
	tag: "tag:yaml.org,2002:js/regexp",
	kind: "scalar",
	resolve(data) {
		if (data === null || !data.length) return false;
		if (data.charAt(0) === "/") {
			const groups = data.match(REGEXP)?.groups;
			if (!groups) return false;
			const modifiers = groups.modifiers ?? "";
			if (new Set(modifiers).size < modifiers.length) return false;
		}
		return true;
	},
	construct(data) {
		const { regexp: regexp$1 = data, modifiers = "" } = data.match(REGEXP)?.groups ?? {};
		return new RegExp(regexp$1, modifiers);
	},
	predicate: (object) => object instanceof RegExp,
	represent: (object) => object.toString()
};
const seq = {
	tag: "tag:yaml.org,2002:seq",
	kind: "sequence",
	resolve: () => true,
	construct: (data) => data !== null ? data : []
};
const set = {
	tag: "tag:yaml.org,2002:set",
	kind: "mapping",
	construct: (data) => data !== null ? data : {},
	resolve: (data) => {
		if (data === null) return true;
		return Object.values(data).every((it) => it === null);
	}
};
const str = {
	tag: "tag:yaml.org,2002:str",
	kind: "scalar",
	resolve: () => true,
	construct: (data) => data !== null ? data : ""
};
const YAML_DATE_REGEXP = /* @__PURE__ */ new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
const YAML_TIMESTAMP_REGEXP = /* @__PURE__ */ new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
function resolveYamlTimestamp(data) {
	if (data === null) return false;
	if (YAML_DATE_REGEXP.exec(data) !== null) return true;
	if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
	return false;
}
function constructYamlTimestamp(data) {
	let match = YAML_DATE_REGEXP.exec(data);
	if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
	if (match === null) throw new Error("Cannot construct YAML timestamp: date resolve error");
	const year = +match[1];
	const month = +match[2] - 1;
	const day = +match[3];
	if (!match[4]) return new Date(Date.UTC(year, month, day));
	const hour = +match[4];
	const minute = +match[5];
	const second = +match[6];
	let fraction = 0;
	if (match[7]) {
		let partFraction = match[7].slice(0, 3);
		while (partFraction.length < 3) partFraction += "0";
		fraction = +partFraction;
	}
	let delta = null;
	if (match[9] && match[10]) {
		const tzHour = +match[10];
		const tzMinute = +(match[11] || 0);
		delta = (tzHour * 60 + tzMinute) * 6e4;
		if (match[9] === "-") delta = -delta;
	}
	const date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
	if (delta) date.setTime(date.getTime() - delta);
	return date;
}
function representYamlTimestamp(date) {
	return date.toISOString();
}
const timestamp = {
	tag: "tag:yaml.org,2002:timestamp",
	construct: constructYamlTimestamp,
	predicate(object) {
		return object instanceof Date;
	},
	kind: "scalar",
	represent: representYamlTimestamp,
	resolve: resolveYamlTimestamp
};
const undefinedType = {
	tag: "tag:yaml.org,2002:js/undefined",
	kind: "scalar",
	resolve() {
		return true;
	},
	construct() {},
	predicate(object) {
		return typeof object === "undefined";
	},
	represent() {
		return "";
	}
};
function createTypeMap(implicitTypes, explicitTypes) {
	const result = {
		fallback: /* @__PURE__ */ new Map(),
		mapping: /* @__PURE__ */ new Map(),
		scalar: /* @__PURE__ */ new Map(),
		sequence: /* @__PURE__ */ new Map()
	};
	const fallbackMap = result.fallback;
	for (const type of [...implicitTypes, ...explicitTypes]) {
		result[type.kind].set(type.tag, type);
		fallbackMap.set(type.tag, type);
	}
	return result;
}
function createSchema({ explicitTypes = [], implicitTypes = [], include }) {
	if (include) {
		implicitTypes.push(...include.implicitTypes);
		explicitTypes.push(...include.explicitTypes);
	}
	return {
		implicitTypes,
		explicitTypes,
		typeMap: createTypeMap(implicitTypes, explicitTypes)
	};
}
const FAILSAFE_SCHEMA = createSchema({ explicitTypes: [
	str,
	seq,
	map
] });
const CORE_SCHEMA = createSchema({ include: createSchema({
	implicitTypes: [
		nil,
		bool,
		int,
		float
	],
	include: FAILSAFE_SCHEMA
}) });
const DEFAULT_SCHEMA = createSchema({
	explicitTypes: [
		binary,
		omap,
		pairs,
		set
	],
	implicitTypes: [timestamp, merge],
	include: CORE_SCHEMA
});
createSchema({
	explicitTypes: [regexp, undefinedType],
	include: DEFAULT_SCHEMA
});
var _computedKey;
function resolveOptions(options) {
	return {
		validator: options.validator,
		allowNoExist: options.allowNoExist ?? true,
		allowValidatorFailure: options.allowValidatorFailure
	};
}
_computedKey = Symbol.dispose;
var LimoFile = class {
	#data;
	#oldData;
	#path;
	#text;
	#options;
	#parseOptions;
	constructor(path$1, options) {
		this.#options = resolveOptions(options);
		this.#parseOptions = options.parseOptions;
		this.#path = path$1;
		const { data, text } = this._read();
		this.#data = this.#oldData = data;
		this.#text = text;
	}
	[_computedKey]() {
		this._write();
	}
	get data() {
		return this.#data;
	}
	set data(value$1) {
		this.#data = value$1;
	}
	_read() {
		if (existsSync(this.#path)) {
			const text = readFileSync(this.#path, { encoding: "utf8" });
			if (text.trim() === "") return {
				data: void 0,
				text
			};
			try {
				const data = this.#parseOptions.parse(text);
				const { validator, allowValidatorFailure } = this.#options;
				if (validator != null && !validator(data)) {
					if (allowValidatorFailure) return {
						data: void 0,
						text
					};
					throw new Error(`Invalid data: ${text}`);
				}
				return {
					data,
					text
				};
			} catch (error) {
				throw new Error(`Failed to parse ${this.#path}: ${error}`);
			}
		}
		if (!this.#options.allowNoExist) throw new Error(`File not found: ${this.#path}`);
		return {
			data: void 0,
			text: void 0
		};
	}
	_write() {
		if (this.#data == null) return;
		try {
			let content;
			if (this.#parseOptions.preserveFormat && this.#text != null && this.#oldData != null) content = this.#parseOptions.preserveFormat(this.#text, this.#oldData, this.#data);
			else content = this.#parseOptions.stringify(this.#data);
			writeFileSync(this.#path, content);
		} catch (error) {
			throw new Error(`Failed to write ${this.#path}: ${error}`);
		}
	}
};
function createLimoJson(path$1, options = {}) {
	return new LimoFile(path$1, {
		...options,
		parseOptions: {
			parse: (text) => JSON.parse(text),
			stringify: (data) => JSON.stringify(data, null, 2)
		}
	});
}
const { stdin: stdin$1 } = process;
async function getStdin() {
	let result = "";
	if (stdin$1.isTTY) return result;
	stdin$1.setEncoding("utf8");
	for await (const chunk of stdin$1) result += chunk;
	return result;
}
getStdin.buffer = async () => {
	const result = [];
	let length = 0;
	if (stdin$1.isTTY) return Buffer.concat([]);
	for await (const chunk of stdin$1) {
		result.push(chunk);
		length += chunk.length;
	}
	return Buffer.concat(result, length);
};
var import_picocolors = /* @__PURE__ */ __toESM(require_picocolors(), 1);
function formatRemainingTime(remaining) {
	const remainingHours = Math.floor(remaining / 60);
	const remainingMins = remaining % 60;
	if (remainingHours > 0) return `${remainingHours}h ${remainingMins}m left`;
	return `${remainingMins}m left`;
}
function getSemaphore(sessionId) {
	const semaphoreDir = join(tmpdir(), "ccusage-semaphore");
	const semaphorePath = join(semaphoreDir, `${sessionId}.lock`);
	mkdirSync(semaphoreDir, { recursive: true });
	return createLimoJson(semaphorePath);
}
const visualBurnRateChoices = [
	"off",
	"emoji",
	"text",
	"emoji-text"
];
const costSourceChoices = [
	"auto",
	"ccusage",
	"cc",
	"both"
];
const contextThresholdSchema = pipe$1(union([number(), pipe$1(string(), trim(), check((value$1) => /^-?\d+$/u.test(value$1), "Context threshold must be an integer"), transform((value$1) => Number.parseInt(value$1, 10)))]), number("Context threshold must be a number"), integer$1("Context threshold must be an integer"), minValue(0, "Context threshold must be at least 0"), maxValue(100, "Context threshold must be at most 100"));
function parseContextThreshold(value$1) {
	return parse$1(contextThresholdSchema, value$1);
}
const statuslineCommand = define({
	name: "statusline",
	description: "Display compact status line for Claude Code hooks with hybrid time+file caching (Beta)",
	toKebab: true,
	args: {
		offline: {
			...sharedArgs.offline,
			default: true
		},
		visualBurnRate: {
			type: "enum",
			choices: visualBurnRateChoices,
			description: "Controls the visualization of the burn rate status",
			default: "off",
			short: "B",
			negatable: false,
			toKebab: true
		},
		costSource: {
			type: "enum",
			choices: costSourceChoices,
			description: "Session cost source: auto (prefer CC then ccusage), ccusage (always calculate), cc (always use Claude Code cost), both (show both costs)",
			default: "auto",
			negatable: false,
			toKebab: true
		},
		cache: {
			type: "boolean",
			description: "Enable cache for status line output (default: true)",
			negatable: true,
			default: true
		},
		refreshInterval: {
			type: "number",
			description: `Refresh interval in seconds for cache expiry (default: ${DEFAULT_REFRESH_INTERVAL_SECONDS})`,
			default: DEFAULT_REFRESH_INTERVAL_SECONDS
		},
		contextLowThreshold: {
			type: "custom",
			description: "Context usage percentage below which status is shown in green (0-100)",
			parse: (value$1) => parseContextThreshold(value$1),
			default: DEFAULT_CONTEXT_USAGE_THRESHOLDS.LOW
		},
		contextMediumThreshold: {
			type: "custom",
			description: "Context usage percentage below which status is shown in yellow (0-100)",
			parse: (value$1) => parseContextThreshold(value$1),
			default: DEFAULT_CONTEXT_USAGE_THRESHOLDS.MEDIUM
		},
		config: sharedArgs.config,
		debug: sharedArgs.debug
	},
	async run(ctx) {
		logger.level = 0;
		if (ctx.values.contextLowThreshold >= ctx.values.contextMediumThreshold) throw new Error(`Context low threshold (${ctx.values.contextLowThreshold}) must be less than medium threshold (${ctx.values.contextMediumThreshold})`);
		const mergedOptions = mergeConfigWithArgs(ctx, loadConfig(ctx.values.config, ctx.values.debug), ctx.values.debug);
		const refreshInterval = mergedOptions.refreshInterval;
		const stdin$2 = await getStdin();
		if (stdin$2.length === 0) {
			log("❌ No input provided");
			process$1.exit(1);
		}
		const hookDataParseResult = safeParse(statuslineHookJsonSchema, JSON.parse(stdin$2.trim()));
		if (!hookDataParseResult.success) {
			log("❌ Invalid input format:", flatten(hookDataParseResult.issues));
			process$1.exit(1);
		}
		const hookData = hookDataParseResult.output;
		const sessionId = hookData.session_id;
		const initialSemaphoreState = pipe(succeed(getSemaphore(sessionId)), map$1((semaphore) => semaphore.data), unwrap(void 0));
		const currentMtime = await getFileModifiedTime(hookData.transcript_path);
		if (mergedOptions.cache && initialSemaphoreState != null) {
			const isExpired = Date.now() - (initialSemaphoreState.lastUpdateTime ?? 0) >= refreshInterval * 1e3;
			const isFileModified = initialSemaphoreState.transcriptMtime !== currentMtime;
			if (!isExpired && !isFileModified) {
				log(initialSemaphoreState.lastOutput);
				return;
			}
			if (initialSemaphoreState.isUpdating === true) {
				const pid = initialSemaphoreState.pid;
				let isProcessAlive = false;
				if (pid != null) try {
					process$1.kill(pid, 0);
					isProcessAlive = true;
				} catch {
					isProcessAlive = false;
				}
				if (isProcessAlive) {
					log(initialSemaphoreState.lastOutput);
					return;
				}
			}
		}
		try {
			var _usingCtx$1 = _usingCtx();
			const currentPid = process$1.pid;
			const semaphore = _usingCtx$1.u(getSemaphore(sessionId));
			if (semaphore.data != null) semaphore.data = {
				...semaphore.data,
				isUpdating: true,
				pid: currentPid
			};
			else {
				const currentMtimeForInit = await getFileModifiedTime(hookData.transcript_path);
				semaphore.data = {
					date: (/* @__PURE__ */ new Date()).toISOString(),
					lastOutput: "",
					lastUpdateTime: 0,
					transcriptPath: hookData.transcript_path,
					transcriptMtime: currentMtimeForInit,
					isUpdating: true,
					pid: currentPid
				};
			}
		} catch (_$1) {
			_usingCtx$1.e = _$1;
		} finally {
			_usingCtx$1.d();
		}
		const mainProcessingResult = pipe(await try_({
			try: async () => {
				const { sessionCost, ccCost, ccusageCost } = await (async () => {
					const costSource = ctx.values.costSource;
					const getCcusageCost = async () => {
						return pipe(try_({
							try: async () => loadSessionUsageById(sessionId, {
								mode: "auto",
								offline: mergedOptions.offline
							}),
							catch: (error) => error
						})(), map$1((sessionCost$1) => sessionCost$1?.totalCost), inspectError((error) => logger.error("Failed to load session data:", error)), unwrap(void 0));
					};
					if (costSource === "both") return {
						ccCost: hookData.cost?.total_cost_usd,
						ccusageCost: await getCcusageCost()
					};
					if (costSource === "cc") return { sessionCost: hookData.cost?.total_cost_usd };
					if (costSource === "ccusage") return { sessionCost: await getCcusageCost() };
					if (costSource === "auto") {
						if (hookData.cost?.total_cost_usd != null) return { sessionCost: hookData.cost.total_cost_usd };
						return { sessionCost: await getCcusageCost() };
					}
					unreachable(costSource);
					return {};
				})();
				const todayStr = (/* @__PURE__ */ new Date()).toISOString().split("T")[0]?.replace(/-/g, "") ?? "";
				const todayCost = await pipe(try_({
					try: async () => loadDailyUsageData({
						since: todayStr,
						until: todayStr,
						mode: "auto",
						offline: mergedOptions.offline
					}),
					catch: (error) => error
				})(), map$1((dailyData) => {
					if (dailyData.length > 0) return calculateTotals(dailyData).totalCost;
					return 0;
				}), inspectError((error) => logger.error("Failed to load daily data:", error)), unwrap(0));
				const { blockInfo, burnRateInfo } = await pipe(try_({
					try: async () => loadSessionBlockData({
						mode: "auto",
						offline: mergedOptions.offline
					}),
					catch: (error) => error
				})(), map$1((blocks) => {
					if (blocks.length === 0) return {
						blockInfo: "No active block",
						burnRateInfo: ""
					};
					const activeBlock = blocks.find((block) => {
						if (!block.isActive) return false;
						return true;
					});
					if (activeBlock != null) {
						const now = /* @__PURE__ */ new Date();
						const remaining = Math.round((activeBlock.endTime.getTime() - now.getTime()) / (1e3 * 60));
						const blockCost = activeBlock.costUSD;
						const blockInfo$1 = `${formatCurrency(blockCost)} block (${formatRemainingTime(remaining)})`;
						const burnRate = calculateBurnRate(activeBlock);
						return {
							blockInfo: blockInfo$1,
							burnRateInfo: burnRate != null ? (() => {
								const renderEmojiStatus = ctx.values.visualBurnRate === "emoji" || ctx.values.visualBurnRate === "emoji-text";
								const renderTextStatus = ctx.values.visualBurnRate === "text" || ctx.values.visualBurnRate === "emoji-text";
								const costPerHour = burnRate.costPerHour;
								const costPerHourStr = `${formatCurrency(costPerHour)}/hr`;
								const burnStatus = burnRate.tokensPerMinuteForIndicator < 2e3 ? "normal" : burnRate.tokensPerMinuteForIndicator < 5e3 ? "moderate" : "high";
								const { emoji, textValue, coloredString } = {
									normal: {
										emoji: "🟢",
										textValue: "Normal",
										coloredString: import_picocolors.default.green
									},
									moderate: {
										emoji: "⚠️",
										textValue: "Moderate",
										coloredString: import_picocolors.default.yellow
									},
									high: {
										emoji: "🚨",
										textValue: "High",
										coloredString: import_picocolors.default.red
									}
								}[burnStatus];
								const burnRateOutputSegments = [coloredString(costPerHourStr)];
								if (renderEmojiStatus) burnRateOutputSegments.push(emoji);
								if (renderTextStatus) burnRateOutputSegments.push(coloredString(`(${textValue})`));
								return ` | 🔥 ${burnRateOutputSegments.join(" ")}`;
							})() : ""
						};
					}
					return {
						blockInfo: "No active block",
						burnRateInfo: ""
					};
				}), inspectError((error) => logger.error("Failed to load block data:", error)), unwrap({
					blockInfo: "No active block",
					burnRateInfo: ""
				}));
				const formatContextInfo = (inputTokens, contextLimit) => {
					const percentage = Math.round(inputTokens / contextLimit * 100);
					const coloredPercentage = (percentage < ctx.values.contextLowThreshold ? import_picocolors.default.green : percentage < ctx.values.contextMediumThreshold ? import_picocolors.default.yellow : import_picocolors.default.red)(`${percentage}%`);
					return `${inputTokens.toLocaleString()} (${coloredPercentage})`;
				};
				const contextInfo = pipe(hookData.context_window != null ? succeed({
					inputTokens: hookData.context_window.total_input_tokens,
					contextLimit: hookData.context_window.context_window_size
				}) : await try_({
					try: async () => calculateContextTokens(hookData.transcript_path, hookData.model.id, mergedOptions.offline),
					catch: (error) => error
				})(), inspectError((error) => logger.debug(`Failed to calculate context tokens: ${error instanceof Error ? error.message : String(error)}`)), map$1((contextResult) => {
					if (contextResult == null) return;
					return formatContextInfo(contextResult.inputTokens, contextResult.contextLimit);
				}), unwrap(void 0));
				return `🤖 ${hookData.model.display_name} | 💰 ${(() => {
					if (ccCost != null || ccusageCost != null) return `(${ccCost != null ? formatCurrency(ccCost) : "N/A"} cc / ${ccusageCost != null ? formatCurrency(ccusageCost) : "N/A"} ccusage)`;
					return sessionCost != null ? formatCurrency(sessionCost) : "N/A";
				})()} session / ${formatCurrency(todayCost)} today / ${blockInfo}${burnRateInfo} | 🧠 ${contextInfo ?? "N/A"}`;
			},
			catch: (error) => error
		})());
		if (isSuccess(mainProcessingResult)) try {
			var _usingCtx3 = _usingCtx();
			const statusLine = mainProcessingResult.value;
			log(statusLine);
			if (!mergedOptions.cache) return;
			const semaphore = _usingCtx3.u(getSemaphore(sessionId));
			semaphore.data = {
				date: (/* @__PURE__ */ new Date()).toISOString(),
				lastOutput: statusLine,
				lastUpdateTime: Date.now(),
				transcriptPath: hookData.transcript_path,
				transcriptMtime: currentMtime,
				isUpdating: false,
				pid: void 0
			};
			return;
		} catch (_$1) {
			_usingCtx3.e = _$1;
		} finally {
			_usingCtx3.d();
		}
		if (isFailure(mainProcessingResult)) try {
			var _usingCtx4 = _usingCtx();
			if (initialSemaphoreState?.lastOutput != null && initialSemaphoreState.lastOutput !== "") log(initialSemaphoreState.lastOutput);
			else log("❌ Error generating status");
			logger.error("Error in statusline command:", mainProcessingResult.error);
			if (!mergedOptions.cache) return;
			const semaphore = _usingCtx4.u(getSemaphore(sessionId));
			if (semaphore.data != null) {
				semaphore.data.isUpdating = false;
				semaphore.data.pid = void 0;
			}
		} catch (_$1) {
			_usingCtx4.e = _$1;
		} finally {
			_usingCtx4.d();
		}
	}
});
const weeklyCommand = define({
	name: "weekly",
	description: "Show usage report grouped by week",
	args: {
		...sharedArgs,
		startOfWeek: {
			type: "enum",
			short: "w",
			description: "Day to start the week on",
			default: "sunday",
			choices: WEEK_DAYS
		}
	},
	toKebab: true,
	async run(ctx) {
		const mergedOptions = mergeConfigWithArgs(ctx, loadConfig(ctx.values.config, ctx.values.debug), ctx.values.debug);
		const useJson = Boolean(mergedOptions.json) || mergedOptions.jq != null;
		if (useJson) logger.level = 0;
		const weeklyData = await loadWeeklyUsageData(mergedOptions);
		if (weeklyData.length === 0) {
			if (useJson) log(JSON.stringify({
				weekly: [],
				totals: {
					inputTokens: 0,
					outputTokens: 0,
					cacheCreationTokens: 0,
					cacheReadTokens: 0,
					totalTokens: 0,
					totalCost: 0
				}
			}, null, 2));
			else logger.warn("No Claude usage data found.");
			process$1.exit(0);
		}
		const totals = calculateTotals(weeklyData);
		if (mergedOptions.debug && !useJson) printMismatchReport(await detectMismatches(void 0), mergedOptions.debugSamples);
		if (useJson) {
			const jsonOutput = {
				weekly: weeklyData.map((data) => ({
					week: data.week,
					inputTokens: data.inputTokens,
					outputTokens: data.outputTokens,
					cacheCreationTokens: data.cacheCreationTokens,
					cacheReadTokens: data.cacheReadTokens,
					totalTokens: getTotalTokens(data),
					totalCost: data.totalCost,
					modelsUsed: data.modelsUsed,
					modelBreakdowns: data.modelBreakdowns
				})),
				totals: createTotalsObject(totals)
			};
			if (mergedOptions.jq != null) {
				const jqResult = await processWithJq(jsonOutput, mergedOptions.jq);
				if (isFailure(jqResult)) {
					logger.error(jqResult.error.message);
					process$1.exit(1);
				}
				log(jqResult.value);
			} else log(JSON.stringify(jsonOutput, null, 2));
		} else {
			logger.box("Claude Code Token Usage Report - Weekly");
			const table = createUsageReportTable({
				firstColumnName: "Week",
				dateFormatter: (dateStr) => formatDateCompact(dateStr, mergedOptions.timezone, mergedOptions.locale ?? void 0),
				forceCompact: ctx.values.compact
			});
			for (const data of weeklyData) {
				const row = formatUsageDataRow(data.week, {
					inputTokens: data.inputTokens,
					outputTokens: data.outputTokens,
					cacheCreationTokens: data.cacheCreationTokens,
					cacheReadTokens: data.cacheReadTokens,
					totalCost: data.totalCost,
					modelsUsed: data.modelsUsed
				});
				table.push(row);
				if (mergedOptions.breakdown) pushBreakdownRows(table, data.modelBreakdowns);
			}
			addEmptySeparatorRow(table, 8);
			const totalsRow = formatTotalsRow({
				inputTokens: totals.inputTokens,
				outputTokens: totals.outputTokens,
				cacheCreationTokens: totals.cacheCreationTokens,
				cacheReadTokens: totals.cacheReadTokens,
				totalCost: totals.totalCost
			});
			table.push(totalsRow);
			log(table.toString());
			if (table.isCompactMode()) {
				logger.info("\nRunning in Compact Mode");
				logger.info("Expand terminal width to see cache metrics and total tokens");
			}
		}
	}
});
const subCommandUnion = [
	["daily", dailyCommand],
	["monthly", monthlyCommand],
	["weekly", weeklyCommand],
	["session", sessionCommand],
	["blocks", blocksCommand],
	["statusline", statuslineCommand]
];
const subCommands = /* @__PURE__ */ new Map();
for (const [name$1, command] of subCommandUnion) subCommands.set(name$1, command);
const mainCommand = dailyCommand;
async function run() {
	let args = process$1.argv.slice(2);
	if (args[0] === "ccusage") args = args.slice(1);
	await cli(args, mainCommand, {
		name,
		version,
		description,
		subCommands,
		renderHeader: null
	});
}
await run();
export {};
